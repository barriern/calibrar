[{"path":"https://roliveros-ramos.github.io/calibrar/articles/calibrar.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Getting started with the `calibrar` package","text":"package allows parameter estimation (.e. calibration) complex models, including stochastic ones. implements generic functions can used fitting type models, especially non-differentiable objective functions, syntax base::optim. supports multiple phases estimation (sequential parameter masking), constrained optimization (bounding box restrictions) automatic parallel computation numerical gradients. common maximum likelihood estimation methods automated construction objective function simulated model outputs provided.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/articles/calibrar.html","id":"basic-usage","dir":"Articles","previous_headings":"","what":"Basic usage","title":"Getting started with the `calibrar` package","text":"vignette covers basic usage package, introducing functions optim2(), optimh() calibrate().","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/articles/calibrar.html","id":"optim2","dir":"Articles","previous_headings":"Basic usage","what":"optim2()","title":"Getting started with the `calibrar` package","text":"name sugests, optim2() intended extend functionality stats::optim() uses arguments (additions): first difference possible values method argument. addition first six methods, also available optim(), optim2() gives access stats::nlm() stats::nlminb() syntax optim() make easy use. addition, three methods optimr package (Rcgmin, Rvmmin, hjn), L-BFGS-B v3 implemented bfgsb3c package AHR-ES (Adaptative Hierarchical Recombination Evolutionary Strategy) implemented package. next example, compare outputs optim() optim2(): results identical, optim2() acts just wrapper optim(). Now, can run example two methods: second difference new argument active, vector indicating parameters optimized (.e. active) fixed constant value optimization process. next example, fix third fourth parameters initial values: can see, final solution, par value keep values 1, initial value provided. numerical gradients computed internally also ‘masked’ parameters derivatives computed speed computation time. Finally, third difference new argument parallel, active parallel computation numerical gradient, gr supplied: last option increase performance computation time fn considerable. explain detail feature following section. Additionally, method computation numerical gradient can chosen within control list:","code":"optim2(   par,   fn,   gr = NULL,   ...,   method = c(\"Nelder-Mead\", \"BFGS\", \"CG\", \"L-BFGS-B\", \"SANN\", \"Brent\", \"nlm\", \"nlminb\",     \"Rcgmin\", \"Rvmmin\", \"hjn\", \"spg\", \"LBFGSB3\", \"AHR-ES\"),   lower = -Inf,   upper = +Inf,   active = NULL,   control = list(),   hessian = FALSE,   parallel = FALSE ) library(calibrar) optim(par=rep(1, 5), fn=function(x) sum(x^2)) #> $par #> [1] -1.931714e-04 -3.044063e-04 -1.744066e-04  1.940552e-05  5.641574e-05 #>  #> $value #> [1] 1.639553e-07 #>  #> $counts #> function gradient  #>      456       NA  #>  #> $convergence #> [1] 0 #>  #> $message #> NULL optim2(par=rep(1, 5), fn=function(x) sum(x^2)) #> $par #> [1] -1.931714e-04 -3.044063e-04 -1.744066e-04  1.940552e-05  5.641574e-05 #>  #> $value #> [1] 1.639553e-07 #>  #> $counts #> function gradient  #>      456       NA  #>  #> $convergence #> [1] 0 #>  #> $message #> NULL optim2(par=rep(1, 5), fn=function(x) sum(x^2), method=\"nlm\") #> $par #> [1] -2.500222e-13 -2.500222e-13 -2.500222e-13 -2.500222e-13 -2.500222e-13 #>  #> $value #> [1] 3.125556e-25 #>  #> $counts #> function gradient  #>       NA       NA  #>  #> $convergence #> [1] 0 #>  #> $message #> [1] \"Relative gradient is close to zero, current iterate is probably solution.\" set.seed(880820) # for reproducibility optim2(par=rep(1, 5), fn=function(x) sum(x^2), method=\"AHR-ES\") #> $par #> [1]  3.749723e-10 -2.023475e-10  1.655858e-10 -2.272363e-10  1.488461e-10 #>  #> $value #> [1] 2.827589e-19 #>  #> $counts #> function gradient  #>     1024        0  #>  #> $convergence #> [1] 0 #>  #> $message #> [1] \"Stopping criteria reached in 128 generations.\" #>  #> $generations #> [1] 128 optim2(par=rep(1, 5), fn=function(x) sum(x^2),         active=c(TRUE, TRUE, FALSE, FALSE, TRUE)) #> Warning in paropt[isActive] <- output$par: number of items to replace is not a #> multiple of replacement length #> $par #> [1] 1.062264e-05 1.167696e-04 1.000000e+00 1.000000e+00 5.492100e-05 #>  #> $value #> [1] 2 #>  #> $counts #> function gradient  #>      202       NA  #>  #> $convergence #> [1] 0 #>  #> $message #> NULL optim2(par=rep(1, 5), fn=function(x) sum(x^2), parallel=TRUE) #> $par #> [1] -1.931714e-04 -3.044063e-04 -1.744066e-04  1.940552e-05  5.641574e-05 #>  #> $value #> [1] 1.639553e-07 #>  #> $counts #> function gradient  #>      456       NA  #>  #> $convergence #> [1] 0 #>  #> $message #> NULL optim2(par=rep(0.5, 5), fn=function(x) sum(2*x^(3.1*x)), control=list(gr.method=\"richardson\")) optim2(par=rep(0.5, 5), fn=function(x) sum(2*x^(3.1*x)), control=list(gr.method=\"central\")) optim2(par=rep(0.5, 5), fn=function(x) sum(2*x^(3.1*x)), control=list(gr.method=\"forward\"))"},{"path":"https://roliveros-ramos.github.io/calibrar/articles/calibrar.html","id":"optimh","dir":"Articles","previous_headings":"Basic usage","what":"optimh()","title":"Getting started with the `calibrar` package","text":"function optimh() similar functionality optim2() acts wrapper several heuristic optimization algorithms implemented several packages: dfoptim, optimr, minqa, cmaes, genSA, DEoptim, soma, rgenoud psoptim. optimh() function standardizes inputs outputs optim(), providing convenient user interface. specific arguments methods can passed original function using control argument. maxit control argument standardized work methods represent maximum number iterations algorithm. However, specific number function evaluations per iteration may vary methods. can refer help pages package details every specific method control arguments.","code":"optimh(   par,   fn,   gr = NULL,   ...,   method = c(\"AHR-ES\", \"Nelder-Mead\", \"SANN\", \"hjn\", \"CMA-ES\", \"genSA\", \"DE\", \"soma\",     \"genoud\", \"PSO\", \"hybridPSO\", \"mads\", \"hjk\", \"hjkb\", \"nmk\", \"nmkb\"),   lower = -Inf,   upper = +Inf,   active = NULL,   control = list(),   hessian = FALSE,   parallel = FALSE ) # Covariance Matrix Adaptation Evolutionary Strategy set.seed(880820) # for reproducibility optimh(par=rep(1, 5), fn=function(x) sum(x^2), method=\"CMA-ES\",        control=list(maxit=200)) #> $par #> [1] -1.848860e-11  3.646458e-11 -8.209875e-11  2.866646e-11 -8.636439e-11 #>  #> $value #> [1] 1.669227e-20 #>  #> $counts #> function gradient  #>     1600       NA  #>  #> $convergence #> [1] 1 #>  #> $message #> NULL # Generalized Simulated Anneling set.seed(880820) # for reproducibility optimh(par=rep(1, 5), fn=function(x) sum(x^2), method=\"genSA\",         lower=rep(-100, 5), upper=rep(100, 5),        control=list(maxit=200, temperature=6000)) #> $par #> [1] 6.988898e-11 6.988898e-11 6.988898e-11 6.988898e-11 6.988898e-11 #>  #> $value #> [1] 2.442235e-20 #>  #> $counts #> function gradient  #>     2024        0  #>  #> $convergence #> [1] 0 #>  #> $message #> [1] NA # Self-Organising Migrating Algorithm set.seed(880820) # for reproducibility optimh(par=rep(1, 5), fn=function(x) sum(x^2), method=\"soma\",        lower=rep(-100, 5), upper=rep(100, 5),        control=list(maxit=200)) #> $par #> [1]  1.519459e-16 -4.704646e-16  8.741813e-17  1.169846e-17 -1.104563e-16 #>  #> $value #> [1] 2.644038e-31 #>  #> $counts #> function gradient  #>     2000       NA  #>  #> $convergence #> [1] 0 #>  #> $message #> [1] NA"},{"path":"https://roliveros-ramos.github.io/calibrar/articles/calibrar.html","id":"running-in-parallel","dir":"Articles","previous_headings":"Basic usage","what":"Running in parallel","title":"Getting started with the `calibrar` package","text":"algorithms implemented optim2() optimh can benefit parallel computation. methods uses numerical computation gradient, calculated parallel. order support type parallel implementation, parallel setup automatic, must done user previous executed optimization, described following example:","code":"library(parallel) ncores = detectCores() - 1 # number of cores to be used cl = makeCluster(ncores) # this is slower than sequential for very fast models (like this one) optim2(par=rep(0.5, 5), fn=function(x) sum(x^2),                 control=list(ncores=ncores), parallel=TRUE) stopCluster(cl) # close the parallel connections"},{"path":[]},{"path":"https://roliveros-ramos.github.io/calibrar/articles/calibrar.html","id":"calibrate","dir":"Articles","previous_headings":"Sequential parameter estimation","what":"calibrate()","title":"Getting started with the `calibrar` package","text":"calibrate() function implements automatic sequential parameter estimation, meaning parameters can un-masked (set active) progressively sequential phases calibration process. basic syntax, calibrate() function work similarly optim2() optimh(), performing simple optimization: upper lower bounds provided, calibrate function can take NA starting values optimization, parameters:","code":"calibrate(   par,   fn,   gr = NULL,   ...,   method = NULL,   lower = NULL,   upper = NULL,   phases = NULL,   control = list(),   hessian = FALSE,   replicates = 1,   parallel = FALSE ) calibrate(par=c(1,2,3,NA,NA), fn=function(x) sum(x^2)) #> Using optimization method 'Rvmmin'. #> Elapsed time: 0.00s #> Function value: 1.24979e-16 #> Parameter values: -5e-09 -5e-09 -5e-09 -5e-09 -5e-09 #>  #> Status: Rvmminu appears to have converged #> Optimization using 'Rvmmin' algorithm. #> Function value: 1.249787e-16  #> Status: Rvmminu appears to have converged  #> Parameters: #> [1] -4.999645e-09 -4.999291e-09 -4.998935e-09 -5.000000e-09 -5.000000e-09 #> Computation: #> function gradient  #>       10        6 calibrate(par=c(1,2,3,NA,5), fn=function(x) sum(x^2),           lower=rep(-100, 5), upper=rep(100, 5)) #> Using optimization method 'Rvmmin'. #> Elapsed time: 0.00s #> Function value: 1.23526e-16 #> Parameter values: -4.98e-09 -4.97e-09 -4.96e-09 -5e-09 -4.94e-09 #>  #> Status: Rvmminb appears to have converged #> Optimization using 'Rvmmin' algorithm. #> Function value: 1.235263e-16  #> Status: Rvmminb appears to have converged  #> Parameters: #> [1] -4.982589e-09 -4.974351e-09 -4.960025e-09 -4.999959e-09 -4.935026e-09 #> Computation: #> function gradient  #>       13        5"},{"path":"https://roliveros-ramos.github.io/calibrar/articles/calibrar.html","id":"setting-up-a-parameter-estimation-with-multiple-phases-","dir":"Articles","previous_headings":"Sequential parameter estimation","what":"Setting up a parameter estimation with multiple phases.","title":"Getting started with the `calibrar` package","text":"Multiple phases can set selecting different one parameter. starting value optimization phase updated best parameters found previous phase: phase set negative number, parameter fixed initial value calibration never optimized:","code":"calibrate(par=c(1,2,3,NA,5), fn=function(x) sum(x^2),           lower=rep(-100, 5), upper=rep(100, 5),           phases=c(1,2,3,2,1)) #> Parameter estimation in three phases. #>  #> - Phase 1: 2 of 5 parameters active. #>  Using optimization method 'Rvmmin'. #>  Phase 1 finished (0.00s) #>  Function value: 13 #>  Parameter values: -2.97e-08 -2.61e-08 #>  #> - Phase 2: 4 of 5 parameters active. #>  Using optimization method 'Rvmmin'. #>  Phase 2 finished (0.00s) #>  Function value: 9 #>  Parameter values: 5.84e-09 -3.93e-08 0 9.41e-09 #>  #> - Phase 3: 5 of 5 parameters active. #>  Using optimization method 'Rvmmin'. #>  Phase 3 finished (0.00s) #>  Function value: 1.24997e-16 #>  Parameter values: -5e-09 -5e-09 -5e-09 -5e-09 -5e-09 #>  #> Status: Rvmminb appears to have converged #> Optimization using 'Rvmmin' algorithm. #> Function value: 1.24997e-16  #> Status: Rvmminb appears to have converged  #> Parameters: #> [1] -5.000004e-09 -5.000078e-09 -4.999605e-09 -5.000002e-09 -5.000006e-09 #> Computation: #> function gradient  #>       11        6 calibrate(par=c(1,2,3,NA,5), fn=function(x) sum(x^2),           lower=rep(-100, 5), upper=rep(100, 5),           phases=c(1,2,-1,2,1)) #> Parameter estimation in two phases. #>  #> - Phase 1: 2 of 5 parameters active. #>  Using optimization method 'Rvmmin'. #>  Phase 1 finished (0.00s) #>  Function value: 13 #>  Parameter values: -2.97e-08 -2.61e-08 #>  #> - Phase 2: 4 of 5 parameters active. #>  Using optimization method 'Rvmmin'. #>  Phase 2 finished (0.00s) #>  Function value: 9 #>  Parameter values: 5.84e-09 -3.93e-08 0 9.41e-09 #>  #> Status: Rvmminb appears to have converged #> Optimization using 'Rvmmin' algorithm. #> Function value: 9  #> Status: Rvmminb appears to have converged  #> Parameters: #> [1]  5.835174e-09 -3.934291e-08  3.000000e+00  0.000000e+00  9.410321e-09 #> * Some parameters are not calibrated. #> Computation: #> function gradient  #>        6        4"},{"path":"https://roliveros-ramos.github.io/calibrar/articles/calibrar.html","id":"dealing-with-stochastic-functions","dir":"Articles","previous_headings":"Sequential parameter estimation","what":"Dealing with stochastic functions","title":"Getting started with the `calibrar` package","text":"dealing stochastic functions, argument replicates can helpful, allows evaluate objective function several times, taking average value actual function value (approximation expected value function). replicates=1, algorithm used default “LBFGSB3”, replicates greater 1, “AHR-ES” used. next examples use function sphereN(), computes Euclidean distance point x origin coordinates random displacement position (see ?sphereN details). set maximum number iterations 1000 speed execution vignette. number replicates can one single value vector length equal number phases:","code":"calibrate(par=c(1,2,3,NA,5), fn=sphereN,           lower=rep(-100, 5), upper=rep(100, 5),           phases=c(1,2,3,2,1), replicates=3, control=list(maxit=1000)) #> Parameter estimation in three phases. #>  #> - Phase 1: 2 of 5 parameters active. #>  Using optimization method 'AHR-ES'. #>  Phase 1 finished (0.85s) #>  Function value: 12.9126 #>  Parameter values: -0.324 0.12 #>  #> - Phase 2: 4 of 5 parameters active. #>  Using optimization method 'AHR-ES'. #>  Phase 2 finished (0.93s) #>  Function value: 10.1169 #>  Parameter values: 0.0695 0.112 0.151 -0.0849 #>  #> - Phase 3: 5 of 5 parameters active. #>  Using optimization method 'AHR-ES'. #>  Phase 3 finished (1.25s) #>  Function value: 0.0534613 #>  Parameter values: -0.00843 0.0767 0.0606 0.0265 0.0048 #>  #> Status: Maximum number of generations or function evaluations reached. #> Optimization using 'AHR-ES' algorithm. #> Function value: 0.05346132  #> Status: Maximum number of generations or function evaluations reached.  #> Parameters: #> [1] -0.008425148  0.076711662  0.060580990  0.026532747  0.004796660 #> Computation: (1000 generations) #> function gradient  #>     8000        0 calibrate(par=c(1,2,3,NA,5), fn=sphereN,           lower=rep(-100, 5), upper=rep(100, 5),           phases=c(1,2,3,2,1), replicates=c(1,1,5), control=list(maxit=1000)) #> Parameter estimation in three phases. #>  #> - Phase 1: 2 of 5 parameters active. #>  Using optimization method 'AHR-ES'. #>  Phase 1 finished (0.70s) #>  Function value: 13.3163 #>  Parameter values: -0.346 -0.101 #>  #> - Phase 2: 4 of 5 parameters active. #>  Using optimization method 'AHR-ES'. #>  Phase 2 finished (0.76s) #>  Function value: 9.8584 #>  Parameter values: 0.217 -0.335 0.24 0.101 #>  #> - Phase 3: 5 of 5 parameters active. #>  Using optimization method 'AHR-ES'. #>  Phase 3 finished (1.26s) #>  Function value: 0.0412229 #>  Parameter values: 0.0282 0.00574 -0.0127 -0.0375 -0.0192 #>  #> Status: Maximum number of generations or function evaluations reached. #> Optimization using 'AHR-ES' algorithm. #> Function value: 0.04122286  #> Status: Maximum number of generations or function evaluations reached.  #> Parameters: #> [1]  0.028236432  0.005735164 -0.012675352 -0.037462605 -0.019210042 #> Computation: (1000 generations) #> function gradient  #>     8000        0"},{"path":"https://roliveros-ramos.github.io/calibrar/articles/calibrar.html","id":"parameters-as-lists","dir":"Articles","previous_headings":"Sequential parameter estimation","what":"Parameters as lists","title":"Getting started with the `calibrar` package","text":"Note function fn must able take list parameter set, user must ensure works beforehand.","code":"calibrate(par=list(par1=c(1,2,3), par2=NA, par3=5), fn=sphereN,           lower=rep(-100, 5), upper=rep(100, 5),           phases=c(1,2,-3,2,1), replicates=c(1,5), control=list(maxit=1000)) #> Parameter estimation in two phases. #>  #> - Phase 1: 2 of 5 parameters active. #>  Using optimization method 'AHR-ES'. #>  Phase 1 finished (0.88s) #>  Function value: 13.1182 #>  Parameter values: 0.0558 0.181 #>  #> - Phase 2: 4 of 5 parameters active. #>  Using optimization method 'AHR-ES'. #>  Phase 2 finished (1.99s) #>  Function value: 8.96767 #>  Parameter values: -0.0167 0.164 -0.14 0.0335 #>  #> Status: Maximum number of generations or function evaluations reached. #> Optimization using 'AHR-ES' algorithm. #> Function value: 8.96767  #> Status: Maximum number of generations or function evaluations reached.  #> Parameters: #>       par11       par12       par13        par2        par3  #> -0.01674863  0.16445070  3.00000000 -0.13951818  0.03351795  #> * Some parameters are not calibrated. #> Computation: (1000 generations) #> function gradient  #>     8000        0"},{"path":"https://roliveros-ramos.github.io/calibrar/articles/calibrar.html","id":"running-in-parallel-1","dir":"Articles","previous_headings":"Sequential parameter estimation","what":"Running in parallel","title":"Getting started with the `calibrar` package","text":"algorithms implemented calibrate function can benefit parallel computation. methods uses numerical computation gradient, calculated parallel optim2(). order support type parallel implementation, parallel setup automatic, must done user previous executed optimization, described following example: parallelising optimization can speed computations, always faster running optimisation sequentially. Parallel execution introduces additional overhead, data communication, thread process management, synchronization, can outweigh benefits objective function relatively fast evaluate. result, computationally inexpensive functions, time required coordinate parallel execution may lead slower performance compared sequential approach. However, evaluation time objective function increases, efficiency gains parallelisation become significant, making valuable strategy complex computationally demanding optimization problems. Please, refer vignette(package=\"calibrar\") additional vignettes calibrar website details.","code":"library(parallel) ncores = detectCores() - 1 # number of cores to be used cl = makeCluster(ncores) # this is slower than sequential for very fast models (like this one) calib = calibrate(par=rep(0.5, 5), fn=sphereN,                   replicates=3,                    lower=rep(-5, 5),                    upper=rep(+5, 5),                    phases=c(1,1,1,2,3),                    control=list(parallel=TRUE, ncores=ncores)) stopCluster(cl) # close the parallel connections"},{"path":"https://roliveros-ramos.github.io/calibrar/articles/v02-parameter_estimation.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Using the `calibrate()` function for parameter estimation","text":"vignette focus use calibrate() parameter estimation. suggest see vignette ‘Getting started calibrar package’ reading one, specially previous experience optimization R.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/articles/v02-parameter_estimation.html","id":"estimating-parameters-for-a-linear-model","dir":"Articles","previous_headings":"","what":"Estimating parameters for a linear model","title":"Using the `calibrate()` function for parameter estimation","text":"first example, estimate parameters linear model manually performing optimization, opposition standard method using stats::lm(). objetive introduce features calibrate() function simple fast model. Let’s start creating parameters linear model. Now, let’s create function simulate linear model. , finally, simulated data exercise: course, solution can found using lm() function: Now, order proceed find solution explicit numerical optimization, need define objective function minimized: now can proceed optimization: expected, able recover real parameters model. Now, let’s specify lower upper bounds algorithms require : repeat exercise several optimization algorithms: compare results: can see, simple example, algorithms used able find solution within reasonable time, faster others. next examples see always case, algorithms can perform differently even fail particular optimization problem.","code":"library(calibrar) N = 7 # number of variables in the linear model T = 100 # number of observations sd = 0.25 # standard deviation of the gaussian noise # observed data x = matrix(rnorm(N*T, sd=sd), nrow=T, ncol=N) # slopes for the linear model (real parameters) slope = seq_len(N)  # intercept for the linear model (real parameters) intercept = pi # real parameters real = list(intercept=intercept, slope=slope) real #> $intercept #> [1] 3.141593 #>  #> $slope #> [1] 1 2 3 4 5 6 7 # function to simulate the linear model linear = function(x, par) {   stopifnot(length(x)==length(par$slope))   out = sum(x*par$slope) + par$intercept   return(out) } # simulated data  y = apply(x, 1, linear, par=real) mod = lm(y ~ x) mod #>  #> Call: #> lm(formula = y ~ x) #>  #> Coefficients: #> (Intercept)           x1           x2           x3           x4           x5   #>       3.142        1.000        2.000        3.000        4.000        5.000   #>          x6           x7   #>       6.000        7.000 # objective function (residual squares sum) obj = function(par, x, y) {   y_sim = apply(x, 1, linear, par=par)   out = sum((y_sim - y)^2)   return(out) } # initial guess for optimization start = list(intercept=0, slope=rep(0, N)) bfgs = calibrate(par=start, fn=obj, x=x, y=y) #> Using optimization method 'Rvmmin'. #> Elapsed time: 0.11s #> Function value: 5.28185e-14 #> Parameter values: 3.14 1 2 3 4 5 6 7 #>  #> Status: Rvmminu appears to have converged # using coef to extract optimal parameters coef(bfgs) #> $intercept #> [1] 3.141593 #>  #> $slope #> [1] 1 2 3 4 5 6 7 lower = relist(rep(-10, N+1), skeleton=start) upper = relist(rep(+10, N+1), skeleton=start) set.seed(880820) # for reproducibility cg = calibrate(par=start, fn=obj, x=x, y=y, method='CG') #> Using optimization method 'CG'. #> Elapsed time: 0.38s #> Function value: 1.00008e-13 #> Parameter values: 3.14 1 2 3 4 5 6 7 #>  #> Status: - nm = calibrate(par=start, fn=obj, x=x, y=y, method='nmkb', lower=lower, upper=upper) #> Using optimization method 'nmkb'. #> Elapsed time: 0.28s #> Function value: 1.09321e-06 #> Parameter values: 3.14 1 2 3 4 5 6 7 #>  #> Status: - ahres = calibrate(par=start, fn=obj, x=x, y=y, method='AHR-ES') #> Using optimization method 'AHR-ES'. #> Elapsed time: 1.88s #> Function value: 1.41888e-18 #> Parameter values: 3.14 1 2 3 4 5 6 7 #>  #> Status: Stopping criteria reached in 241 generations. hjn = calibrate(par=start, fn=obj, x=x, y=y, method='hjn', lower=lower, upper=upper) #> Using optimization method 'hjn'. #> Elapsed time: 0.47s #> Function value: 2.15391e-13 #> Parameter values: 3.14 1 2 3 4 5 6 7 #>  #> Status: - summary(ahres, hjn, nm, bfgs, cg, par.only=TRUE) #>       method intercept slope1 slope2 slope3 slope4 slope5 slope6 slope7 #> ahres AHR-ES      3.14      1      2      3      4      5      6      7 #> hjn      hjn      3.14      1      2      3      4      5      6      7 #> nm      nmkb      3.14      1      2      3      4      5      6      7 #> bfgs  Rvmmin      3.14      1      2      3      4      5      6      7 #> cg        CG      3.14      1      2      3      4      5      6      7"},{"path":"https://roliveros-ramos.github.io/calibrar/articles/v02-parameter_estimation.html","id":"fitting-a-biomass-production-model-with-harvest","dir":"Articles","previous_headings":"","what":"Fitting a biomass production model with harvest","title":"Using the `calibrate()` function for parameter estimation","text":"second example, estimate parameters difference equation system, simulating dynamics biomass B harvested population: B_{t+1} = B_t + rB_t\\left(1-\\frac{B_t}{K}\\right) - C_t, B_t biomass time t, C_t catch interval [t, t+1[, r intrinsic population growth rate K carrying capacity system. define values parameters can perform optimization try recover simulated data: , function simulate data parameters (model) needed. requirement function first argument parameter vector (list) par: now can use run_model() function assumed parameters simulate model:  order carry optimization, need objective function defined, case, using simple residual squares sum: Finally, need define starting point search, ready try estimate parameters using several algorithms: function summary() can used compare optimization results: better comparison, can simulate results parameters found: plot best results obtained (L-BFGS-B 3.0, CG AHR-ES):  far, used algorithms default arguments. algorithms provide control arguments allow improve performance particular problem. example, looking back results L-BFGS-B 3.0 method, can see status ‘Maximum number iterations reached’, meaning algorithm converge stopped maximum number 100 iterations allowed default. can modified (several methods) changing maxit control argument: can see setup, algorithm converges right solution. also possibility set calibration multiple phases, meaning solve several sequential optimizations progressively higher number parameters. purpose improve initial search point final optimization parameters active. heuristic may help achieve find solution problems. example, Rvmmin algorithm status ‘Rvmminu appears converged’ able converge original parameter values. , try fixing parameters (initial biomass) trying two phases parameter estimation: two phases, now also find solution using ‘Rvmmin’ method.","code":"set.seed(880820) T = 50 real = list(r=0.5, K=1000, B0=600) catch = 0.25*(real$r*real$K)*runif(T, min=0.2, max=1.8) run_model = function(par, T, catch) {   B = numeric(T+1)   times = seq(0, T)   B0 = par$B0   r = par$r   K = par$K   B[1] = B0   for(t in seq_len(T)) {     b = B[t] + r*B[t]*(1-B[t]/K) - catch[t] # could be negative     B[t+1] = max(b, 0.01*B[t]) # smooth aproximation to zero   }   out = list(biomass=B)   return(out) } observed = run_model(par=real, T=T, catch=catch) par(mfrow=c(2,1), mar=c(3,3,1,1), oma=c(1,1,1,1)) plot(observed$biomass, type=\"l\", lwd=2, ylab=\"biomass\", xlab=\"\", las=1, ylim=c(0, 1.2*max(observed$biomass))) mtext(\"BIOMASS\", 3, adj=0.01, line = 0, font=2) plot(catch, type=\"h\", lwd=2, ylab=\"catch\", xlab=\"\", las=1, ylim=c(0, 1.2*max(catch))) mtext(\"CATCH\", 3, adj=0.01, line = 0, font=2) objfn = function(par, T, catch, observed) {   simulated = run_model(par=par, T=T, catch=catch)   value = sum((observed$biomass-simulated$biomass)^2, na.rm=TRUE)   return(value) } start = list(r=0.1, K=1.5*max(observed$biomass), B0=observed$biomass[1]) set.seed(880820) # for reproducibility opt0 = calibrate(par=start, fn = objfn, method='LBFGSB3', T=T, catch=catch, observed=observed) #> Using optimization method 'LBFGSB3'. #> Elapsed time: 0.05s #> Function value: 34239.4 #> Parameter values: 0.476 1.04e+03 535 #>  #> Status: Maximum number of iterations reached opt1 = calibrate(par=start, fn = objfn, method='Rvmmin', T=T, catch=catch, observed=observed) #> Using optimization method 'Rvmmin'. #> Elapsed time: 0.02s #> Function value: 1.34546e+07 #> Parameter values: 2.9 1.14e+03 482 #>  #> Status: Rvmminu appears to have converged opt2 = calibrate(par=start, fn = objfn, method='CG', T=T, catch=catch, observed=observed) #> Using optimization method 'CG'. #> Elapsed time: 0.08s #> Function value: 150931 #> Parameter values: 0.402 1.18e+03 600 #>  #> Status: - opt3 = calibrate(par=start, fn = objfn, method='AHR-ES', T=T, catch=catch, observed=observed) #> Using optimization method 'AHR-ES'. #> Elapsed time: 2.39s #> Function value: 6.77545e-17 #> Parameter values: 0.5 1e+03 600 #>  #> Status: Stopping criteria reached in 1590 generations. opt4 = calibrate(par=start, fn = objfn, method='CMA-ES', T=T, catch=catch, observed=observed) #> Using optimization method 'CMA-ES'. #> Elapsed time: 0.19s #> Function value: 107373 #> Parameter values: 0.446 1.09e+03 689 #>  #> Status: Covariance matrix 'C' is numerically not positive definite. opt5 = calibrate(par=start, fn = objfn, method='hjn', T=T, catch=catch, observed=observed) #> Using optimization method 'hjn'. #> Elapsed time: 0.75s #> Function value: 990.8 #> Parameter values: 0.509 988 602 #>  #> Status: - opt6 = calibrate(par=start, fn = objfn, method='Nelder-Mead', T=T, catch=catch, observed=observed) #> Using optimization method 'Nelder-Mead'. #> Elapsed time: 0.03s #> Function value: 0.0775804 #> Parameter values: 0.5 1e+03 600 #>  #> Status: - summary(opt0, opt1, opt2, opt3, opt4, opt5, opt6) #>           method elapsed    value    fn  gr     r    K  B0 #> opt0     LBFGSB3  0.0482 3.42e+04   100 100 0.476 1039 535 #> opt1      Rvmmin  0.0164 1.35e+07   161   8 2.900 1145 482 #> opt2          CG  0.0819 1.51e+05   691 101 0.402 1181 600 #> opt3      AHR-ES  2.3910 6.78e-17 11130   0 0.500 1000 600 #> opt4      CMA-ES  0.1955 1.07e+05  1085  NA 0.446 1090 689 #> opt5         hjn  0.7526 9.91e+02  6000  NA 0.509  988 602 #> opt6 Nelder-Mead  0.0268 7.76e-02   221  NA 0.500 1000 600 sim0 = run_model(par=coef(opt0), T=T, catch=catch) sim1 = run_model(par=coef(opt1), T=T, catch=catch) sim2 = run_model(par=coef(opt2), T=T, catch=catch) sim3 = run_model(par=coef(opt3), T=T, catch=catch) sim4 = run_model(par=coef(opt4), T=T, catch=catch) sim5 = run_model(par=coef(opt5), T=T, catch=catch) par(mar=c(3,4,1,1)) plot(observed$biomass, type=\"n\", ylab=\"BIOMASS\", xlab=\"\", las=1, ylim=c(0, 1.2*max(observed$biomass))) lines(sim0$biomass, col=1, lwd=2) lines(sim2$biomass, col=2, lwd=2) lines(sim3$biomass, col=3, lwd=2) points(observed$biomass) mtext(c('LBFGSB3', 'CG', 'AHR-ES'), 1, adj=0.05, col=1:3, line=-(4:2), font=2) optx = calibrate(par=start, fn = objfn, method='LBFGSB3', T=T, catch=catch, observed=observed, control=list(maxit=20000)) #> Using optimization method 'LBFGSB3'. #> Elapsed time: 0.01s #> Function value: 150998 #> Parameter values: 0.402 1.18e+03 600 #>  #> Status: CONVERGENCE: Parameters differences below xtol calibrate(par=start, fn = objfn, method='Rvmmin', T=T, catch=catch, observed=observed, phases = c(1,1,2)) #> Parameter estimation in two phases. #>  #> - Phase 1: 2 of 3 parameters active. #>  Using optimization method 'Rvmmin'. #>  Phase 1 finished (0.01s) #>  Function value: 1.8303e-08 #>  Parameter values: 0.5 1e+03 #>  #> - Phase 2: 3 of 3 parameters active. #>  Using optimization method 'Rvmmin'. #>  Phase 2 finished (0.00s) #>  Function value: 1.8303e-08 #>  Parameter values: 0.5 1e+03 600 #>  #> Status: Rvmminu appears to have converged #> Optimization using 'Rvmmin' algorithm. #> Function value: 1.830304e-08  #> Status: Rvmminu appears to have converged  #> Parameters: #>     r     K    B0  #> 5e-01 1e+03 6e+02  #> Computation: #> function gradient  #>       18        1"},{"path":"https://roliveros-ramos.github.io/calibrar/articles/v02-parameter_estimation.html","id":"fitting-an-autoregressive-poisson-model","dir":"Articles","previous_headings":"","what":"Fitting an autoregressive Poisson model","title":"Using the `calibrate()` function for parameter estimation","text":"third example, estimate parameters Poisson Autoregressive Mixed model dynamics population different sites: log(\\mu_{, t+1}) = log(\\mu_{, t}) + \\alpha + \\beta X_{, t} + \\gamma_t \\mu_{, t} size population site year t, X_{, t} value environmental variable site year t. parameters estimate \\alpha, \\beta, \\gamma_t, random effects year, \\gamma_t \\sim N(0,\\sigma^2), initial population site \\mu_{, 0}. assumed observations N_{,t} follow Poisson distribution mean \\mu_{, t}. also create data model using function calibrar_demo(), additional arguments L=5 (five sites) T=100 (one hundred years): , also added control list increase maximum number iterations algorithms tolerance convergence. Now can specify run_model() function can simulate model parameter set define objective function using calibration_objFn() function: can proceed parameter estimation. , compare performance three BFGS type algorithms: case, best solution found using ‘Rvmmin’ algorithm, also faster (12.2s). Now, can try carry parameter estimation two phases: re-every optimization: algorithms, can see improvement solution found even speed time needed optimization first two methods (‘L-BFGS-B’, ‘Rvmmin’). Finally, can try carry optimization two phases, using different algorithms phase. principle, algorithms may faster find better initial starting point final search. , can see every combination find essentially solution, combination using ‘CG’ (conjugated gradient) first required less function gradient evaluations, faster. Please, refer vignette(package=\"calibrar\") additional vignettes calibrar website details.","code":"path = NULL # NULL to use the current directory ARPM = calibrar_demo(path=path, model=\"PoissonMixedModel\", L=5, T=100)  #> Creating observed data list for calibration... #> Loaded observed data for variables: 'site_1', 'site_2', 'site_3', 'site_4', 'site_5'. setup = calibration_setup(file=ARPM$setup) observed = calibration_data(setup=setup, path=ARPM$path) #> Creating observed data list for calibration... #>  #> Loaded observed data for variables: 'site_1', 'site_2', 'site_3', 'site_4', 'site_5'. forcing = as.matrix(read.csv(file.path(ARPM$path, \"master\", \"environment.csv\"), row.names=1)) control = list(maxit=20000, eps=sqrt(.Machine$double.eps), factr=sqrt(.Machine$double.eps)) run_model = function(par, forcing) {   output = calibrar:::.PoissonMixedModel(par=par, forcing=forcing)   output = c(output, list(gammas=par$gamma)) # adding gamma parameters for penalties   return(output) } obj = calibration_objFn(model=run_model, setup=setup, observed=observed, forcing=forcing, aggregate=TRUE) # real parameters coef(ARPM) #> $alpha #> [1] 0.4 #>  #> $beta #> [1] -0.4 #>  #> $gamma #>  [1] -0.1252736456  0.0962670651  0.3390542168 -0.3522452588  0.0396026030 #>  [6]  0.0794698198  0.0058450990  0.5120546777  0.2514255423 -0.1069075371 #> [11] -0.1250454857  0.1827697374  0.2014399069  0.1438583647 -0.1209423322 #> [16]  0.1078108813 -0.0153661771  0.3699839121 -0.1709815103  0.0065274590 #> [21] -0.2050118962 -0.1964498151  0.0008203914 -0.0466854356 -0.0997776438 #> [26]  0.3099425926  0.0174993833  0.2637402261 -0.1962448238 -0.0491245175 #> [31] -0.2807867674  0.2881786295 -0.1962719982  0.2948489808 -0.1982394491 #> [36] -0.0188994689 -0.5750283368 -0.0493732202  0.0029488980 -0.3838175407 #> [41] -0.0575627487 -0.0693274891 -0.3679177169  0.1797177882 -0.2425710022 #> [46] -0.0437928463  0.1128536321 -0.1050868751  0.1488748450  0.0257963506 #> [51]  0.2976548514 -0.1325363902 -0.2321310003  0.0717548469 -0.0389692768 #> [56] -0.0590564016  0.0993280847  0.0969825576  0.0037569001  0.1269549129 #> [61]  0.1508888175  0.1667178070  0.1931522592  0.2587759936 -0.0273102042 #> [66] -0.0880277376 -0.2454567829 -0.0475306139 -0.1853716313  0.0822470712 #> [71] -0.0397729154 -0.1114899279 -0.1954314245  0.0121470497 -0.1194458959 #> [76] -0.2517897395 -0.2820094403  0.2202608159 -0.1354484053 -0.1524347015 #> [81] -0.0583497204 -0.1150377059 -0.0887883736 -0.0625140888 -0.1206008853 #> [86] -0.2187869440  0.1429412383 -0.0217624526 -0.2887595871  0.1612246527 #> [91] -0.3479670157 -0.0802640619 -0.0575164978 -0.1876814800  0.0575334278 #> [96] -0.3010802249  0.3038594027  0.0734818712  0.3399724818 #>  #> $sd #> [1] 0.2 #>  #> $mu_ini #> [1] 5.141664 4.158883 3.433987 4.430817 4.934474 lbfgsb1 = calibrate(par=ARPM$guess, fn=obj, method='L-BFGS-B', lower=ARPM$lower, upper=ARPM$upper, phases=ARPM$phase, control=control) #> Using optimization method 'L-BFGS-B'. #> Elapsed time: 1m 30.0s #> Function value: -186093 #> Parameter values: 0.43 -0.415 -0.109 0.103 0.224 -0.306 0.0191 0.0445 0.0534 0.432 0.199 -0.0786 -0.128 0.121 0.275 0.0471 -0.101 0.0981 -0.0389 0.371 -0.213 0.036 -0.237 -0.254 0.0572 -0.0642 -0.178 0.294 5.54e-05 0.268 -0.212 -0.0516 -0.325 0.253 -0.195 0.291 -0.243 -0.0235 -0.532 -0.0742 -0.0616 -0.297 -0.115 -0.167 -0.323 0.0585 -0.185 -0.0309 0.0992 -0.0813 0.0103 0.161 0.266 -0.103 -0.368 0.0792 -0.133 0.0369 0.0815 -0.000515 0.0957 -0.0619 0.287 0.185 0.134 0.162 0.0492 -0.143 -0.124 -0.163 -0.277 0.0741 -0.0474 -0.0123 -0.229 -0.0587 -0.17 -0.183 -0.226 -0.0318 -0.0141 -0.21 -0.0744 -0.1 -0.185 -0.137 -0.0275 -0.164 0.181 -0.2 -0.243 0.152 -0.284 -0.352 -0.0418 -0.188 0.0203 -0.0106 0.197 -0.0425 0.37 #>  #> Status: CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH lbfgsb2 = calibrate(par=ARPM$guess, fn=obj, method='Rvmmin', lower=ARPM$lower, upper=ARPM$upper, phases=ARPM$phase, control=control) #> Using optimization method 'Rvmmin'. #> Elapsed time: 19.96s #> Function value: -186095 #> Parameter values: 0.397 -0.415 -0.0755 0.135 0.261 -0.276 0.0524 0.0757 0.085 0.467 0.231 -0.0459 -0.0946 0.155 0.308 0.0794 -0.0678 0.131 -0.00842 0.405 -0.181 0.0701 -0.205 -0.221 0.0894 -0.0332 -0.145 0.326 0.0332 0.301 -0.179 -0.0193 -0.291 0.284 -0.161 0.323 -0.209 0.00885 -0.5 -0.0401 -0.0301 -0.27 -0.0754 -0.135 -0.295 0.0923 -0.154 0.00403 0.137 -0.0503 0.0357 0.194 0.307 -0.0752 -0.339 0.117 -0.101 0.0691 0.114 0.0343 0.129 -0.0325 0.325 0.217 0.164 0.197 0.0826 -0.113 -0.0906 -0.128 -0.25 0.111 -0.015 0.0211 -0.201 -0.0202 -0.134 -0.154 -0.195 0.0029 0.0188 -0.179 -0.0423 -0.0657 -0.151 -0.104 0.00175 -0.13 0.209 -0.167 -0.206 0.187 -0.246 -0.32 -0.00722 -0.145 3.35e-05 0.0373 0.242 0.00104 0.408 #>  #> Status: Rvmminb appears to have converged lbfgsb3 = calibrate(par=ARPM$guess, fn=obj, method='LBFGSB3', lower=ARPM$lower, upper=ARPM$upper, phases=ARPM$phase, control=control) #> Using optimization method 'LBFGSB3'. #> Elapsed time: 36.10s #> Function value: -182467 #> Parameter values: 0.378 -0.16 -0.188 -0.183 -0.181 -0.201 -0.162 -0.145 -0.144 -0.129 -0.124 -0.145 -0.145 -0.144 -0.122 -0.145 -0.154 -0.156 -0.174 -0.164 -0.254 -0.26 -0.276 -0.286 -0.276 -0.235 -0.217 -0.19 -0.188 -0.18 -0.246 -0.254 -0.27 -0.222 -0.269 -0.264 -0.324 -0.331 -0.337 -0.337 -0.337 -0.337 -0.335 -0.329 -0.325 -0.342 -0.342 -0.342 -0.248 -0.236 -0.219 -0.213 -0.215 -0.203 -0.216 -0.194 -0.193 -0.14 -0.165 -0.152 -0.15 -0.149 -0.146 -0.146 -0.146 -0.149 -0.164 -0.101 -0.399 -0.26 -0.296 -0.304 -0.278 -0.294 -0.315 -0.291 -0.312 -0.384 -0.328 -0.34 -0.341 -0.296 -0.327 -0.283 -0.284 -0.28 -0.3 -0.224 -0.253 -0.284 -0.319 -0.293 -0.337 -0.338 -0.337 -0.291 -0.331 -0.125 -0.0377 -0.195 -0.157 #>  #> Status: CONVERGENCE: REL_REDUCTION_OF_F_<=_FACTR*EPSMCH summary(ARPM, lbfgsb1, lbfgsb2, lbfgsb3, show_par = 1:3) #>           method elapsed   value   fn   gr alpha   beta  gamma1 #> ARPM        data      NA -186178   NA   NA 0.400 -0.400 -0.1253 #> lbfgsb1 L-BFGS-B    90.0 -186093 2082 2082 0.430 -0.415 -0.1085 #> lbfgsb2   Rvmmin    20.0 -186095 2701  425 0.397 -0.415 -0.0755 #> lbfgsb3  LBFGSB3    36.1 -182467 1131 1131 0.378 -0.160 -0.1883 phases = ARPM$phase phases$gamma[] = 2 lbfgsb1p = calibrate(par=ARPM$guess, fn=obj, method='L-BFGS-B', lower=ARPM$lower, upper=ARPM$upper, phases=phases, control=control) #> Parameter estimation in two phases. #>  #> - Phase 1: 2 of 107 parameters active. #>  Using optimization method 'L-BFGS-B'. #>  Phase 1 finished (0.08s) #>  Function value: -169005 #>  Parameter values: 0.292 -0.295 #>  #> - Phase 2: 101 of 107 parameters active. #>  Using optimization method 'L-BFGS-B'. #>  Phase 2 finished (1m 17.5s) #>  Function value: -186095 #>  Parameter values: 0.402 -0.414 -0.0807 0.13 0.256 -0.282 0.0487 0.0714 0.0787 0.462 0.226 -0.051 -0.0995 0.15 0.303 0.0746 -0.0727 0.126 -0.0115 0.398 -0.185 0.0649 -0.21 -0.226 0.0837 -0.0368 -0.15 0.32 0.029 0.295 -0.184 -0.0241 -0.296 0.28 -0.166 0.319 -0.212 0.000427 -0.505 -0.0438 -0.0344 -0.275 -0.0804 -0.139 -0.302 0.091 -0.161 -0.0019 0.134 -0.0566 0.0311 0.19 0.303 -0.0796 -0.347 0.116 -0.109 0.0654 0.11 0.0279 0.125 -0.0395 0.321 0.212 0.159 0.192 0.0779 -0.118 -0.0954 -0.133 -0.256 0.107 -0.0206 0.0175 -0.206 -0.0245 -0.14 -0.158 -0.202 0.00014 0.0158 -0.185 -0.0462 -0.07 -0.158 -0.11 -0.00274 -0.134 0.205 -0.174 -0.21 0.182 -0.252 -0.324 -0.0247 -0.16 0.0434 0.0196 0.224 0.0019 0.4 #>  #> Status: CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH lbfgsb2p = calibrate(par=ARPM$guess, fn=obj, method='Rvmmin', lower=ARPM$lower, upper=ARPM$upper, phases=phases, control=control) #> Parameter estimation in two phases. #>  #> - Phase 1: 2 of 107 parameters active. #>  Using optimization method 'Rvmmin'. #>  Phase 1 finished (0.04s) #>  Function value: -169005 #>  Parameter values: 0.292 -0.295 #>  #> - Phase 2: 101 of 107 parameters active. #>  Using optimization method 'Rvmmin'. #>  Phase 2 finished (16.12s) #>  Function value: -186095 #>  Parameter values: 0.396 -0.415 -0.0743 0.136 0.262 -0.274 0.0536 0.0769 0.0863 0.468 0.232 -0.0446 -0.0934 0.156 0.309 0.0806 -0.0666 0.133 -0.0072 0.406 -0.179 0.0713 -0.204 -0.22 0.0907 -0.0319 -0.143 0.327 0.0345 0.302 -0.177 -0.018 -0.29 0.285 -0.16 0.324 -0.208 0.0101 -0.499 -0.0388 -0.0289 -0.268 -0.0741 -0.134 -0.293 0.0936 -0.152 0.00322 0.139 -0.049 0.0369 0.196 0.308 -0.074 -0.338 0.119 -0.1 0.0704 0.115 0.0355 0.13 -0.0313 0.326 0.219 0.166 0.198 0.0839 -0.111 -0.0894 -0.127 -0.249 0.112 -0.0137 0.0224 -0.2 -0.019 -0.133 -0.152 -0.194 0.00318 0.0207 -0.178 -0.041 -0.0644 -0.15 -0.104 0.00367 -0.129 0.21 -0.165 -0.204 0.188 -0.247 -0.324 0.000263 -0.167 0.0532 0.0194 0.239 -0.00296 0.41 #>  #> Status: Rvmminb appears to have converged lbfgsb3p = calibrate(par=ARPM$guess, fn=obj, method='LBFGSB3', lower=ARPM$lower, upper=ARPM$upper, phases=phases, control=control) #> Parameter estimation in two phases. #>  #> - Phase 1: 2 of 107 parameters active. #>  Using optimization method 'LBFGSB3'. #>  Phase 1 finished (37.43s) #>  Function value: -169005 #>  Parameter values: 0.295 -0.298 #>  #> - Phase 2: 101 of 107 parameters active. #>  Using optimization method 'LBFGSB3'. #>  Phase 2 finished (1m 1.5s) #>  Function value: -185064 #>  Parameter values: 0.304 -0.307 0.0233 0.0429 0.0495 0.0137 0.0515 0.0838 0.109 0.108 0.11 0.0873 0.0845 0.0942 0.1 0.0798 0.0588 0.0735 0.0701 0.0779 -0.0545 -0.0593 -0.0548 -0.0543 -0.0455 -0.0321 0.00338 0.0661 0.05 0.07 0.000428 -0.0352 -0.0667 -0.0251 -0.0384 -0.0379 -0.112 -0.114 -0.116 -0.116 -0.115 -0.115 -0.114 -0.127 -0.111 -0.109 -0.101 -0.0863 -0.0276 -0.0152 0.0156 0.0474 0.0354 0.044 0.00469 0.0399 0.0138 0.045 0.0565 0.0666 0.0677 0.0677 0.0677 0.0677 0.0677 0.0677 0.0562 0.00464 -0.0632 -0.0827 -0.0873 0.109 -0.114 -0.0975 -0.118 -0.103 -0.156 -0.104 -0.128 -0.106 -0.101 -0.0944 -0.0855 -0.0806 -0.0918 -0.0728 -0.0384 -0.0839 -0.0173 -0.0522 -0.102 -0.0172 -0.161 -0.185 -0.0937 -0.076 -0.0238 -0.0193 0.0545 0.00427 0.198 #>  #> Status: CONVERGENCE: REL_REDUCTION_OF_F_<=_FACTR*EPSMCH summary(ARPM, lbfgsb1, lbfgsb1p, lbfgsb2, lbfgsb2p, lbfgsb3, lbfgsb3p, show_par = 1:3) #>            method elapsed   value   fn   gr alpha   beta  gamma1 #> ARPM         data      NA -186178   NA   NA 0.400 -0.400 -0.1253 #> lbfgsb1  L-BFGS-B    90.0 -186093 2082 2082 0.430 -0.415 -0.1085 #> lbfgsb1p L-BFGS-B    77.6 -186095 1998 1998 0.402 -0.414 -0.0807 #> lbfgsb2    Rvmmin    20.0 -186095 2701  425 0.397 -0.415 -0.0755 #> lbfgsb2p   Rvmmin    16.2 -186095 2080  329 0.396 -0.415 -0.0743 #> lbfgsb3   LBFGSB3    36.1 -182467 1131 1131 0.378 -0.160 -0.1883 #> lbfgsb3p  LBFGSB3    98.9 -185064 1389 1389 0.304 -0.307  0.0233 mix1 = calibrate(par=ARPM$guess, fn=obj, method=c('hjn', 'Rvmmin'), lower=ARPM$lower, upper=ARPM$upper, phases=phases, control=control) #> Parameter estimation in two phases. #>  #> - Phase 1: 2 of 107 parameters active. #>  Using optimization method 'hjn'. #>  Phase 1 finished (1.87s) #>  Function value: -169005 #>  Parameter values: 0.294 -0.298 #>  #> - Phase 2: 101 of 107 parameters active. #>  Using optimization method 'Rvmmin'. #>  Phase 2 finished (29.21s) #>  Function value: -186095 #>  Parameter values: 0.396 -0.415 -0.0739 0.136 0.262 -0.274 0.054 0.0773 0.0866 0.469 0.232 -0.0443 -0.093 0.156 0.309 0.081 -0.0663 0.133 -0.00675 0.406 -0.179 0.0717 -0.204 -0.22 0.0911 -0.0316 -0.143 0.327 0.0348 0.302 -0.177 -0.0177 -0.289 0.286 -0.159 0.325 -0.208 0.0106 -0.499 -0.0385 -0.0285 -0.268 -0.0737 -0.134 -0.293 0.0938 -0.153 0.00605 0.138 -0.0487 0.0374 0.196 0.308 -0.0736 -0.337 0.119 -0.0999 0.0708 0.116 0.036 0.13 -0.0312 0.326 0.219 0.166 0.198 0.0843 -0.111 -0.089 -0.127 -0.249 0.113 -0.0129 0.0226 -0.199 -0.0183 -0.132 -0.152 -0.192 -0.000484 0.0229 -0.177 -0.0406 -0.064 -0.15 -0.104 0.00688 -0.13 0.21 -0.165 -0.204 0.188 -0.246 -0.324 0.00128 -0.167 0.0528 0.0208 0.24 -0.00361 0.411 #>  #> Status: Rvmminb appears to have converged mix2 = calibrate(par=ARPM$guess, fn=obj, method=c('Nelder-Mead', 'Rvmmin'), lower=ARPM$lower, upper=ARPM$upper, phases=phases, control=control) #> Parameter estimation in two phases. #>  #> - Phase 1: 2 of 107 parameters active. #>  Using optimization method 'Nelder-Mead'. #>  Phase 1 finished (0.01s) #>  Function value: -124445 #>  Parameter values: 0.308 -0.358 #>  #> - Phase 2: 101 of 107 parameters active. #>  Using optimization method 'Rvmmin'. #>  Phase 2 finished (33.78s) #>  Function value: -186095 #>  Parameter values: 0.396 -0.415 -0.074 0.136 0.262 -0.274 0.0539 0.0772 0.0866 0.468 0.232 -0.0444 -0.0931 0.156 0.309 0.0809 -0.0663 0.133 -0.00686 0.406 -0.179 0.0716 -0.204 -0.22 0.0909 -0.0316 -0.143 0.327 0.0348 0.302 -0.177 -0.0178 -0.289 0.286 -0.159 0.324 -0.208 0.0105 -0.499 -0.0386 -0.0287 -0.268 -0.0738 -0.134 -0.293 0.0939 -0.152 0.0051 0.138 -0.0488 0.0372 0.196 0.308 -0.0737 -0.337 0.119 -0.0999 0.0706 0.116 0.0359 0.13 -0.031 0.326 0.219 0.166 0.198 0.0842 -0.111 -0.0891 -0.127 -0.249 0.113 -0.0132 0.0226 -0.199 -0.0186 -0.132 -0.152 -0.192 -0.00097 0.0229 -0.177 -0.0407 -0.0642 -0.15 -0.104 0.00515 -0.129 0.21 -0.165 -0.204 0.188 -0.246 -0.324 0.000538 -0.167 0.0529 0.0204 0.238 -8.15e-05 0.409 #>  #> Status: Rvmminb appears to have converged mix3 = calibrate(par=ARPM$guess, fn=obj, method=c('CG', 'Rvmmin'), lower=ARPM$lower, upper=ARPM$upper, phases=phases, control=control) #> Parameter estimation in two phases. #>  #> - Phase 1: 2 of 107 parameters active. #>  Using optimization method 'CG'. #>  Phase 1 finished (0.02s) #>  Function value: -1824.73 #>  Parameter values: 2.33e+03 2.36e+03 #>  #> - Phase 2: 101 of 107 parameters active. #>  Using optimization method 'Rvmmin'. #>  Phase 2 finished (9.82s) #>  Function value: -186095 #>  Parameter values: 0.396 -0.415 -0.0746 0.136 0.262 -0.275 0.0533 0.0765 0.086 0.468 0.232 -0.045 -0.0937 0.156 0.309 0.0803 -0.0669 0.132 -0.0076 0.406 -0.18 0.071 -0.204 -0.22 0.0903 -0.0322 -0.144 0.327 0.0341 0.302 -0.178 -0.0184 -0.29 0.285 -0.16 0.324 -0.208 0.00983 -0.5 -0.0391 -0.0293 -0.269 -0.0744 -0.134 -0.294 0.0933 -0.153 0.00378 0.138 -0.0493 0.0366 0.195 0.308 -0.0743 -0.338 0.118 -0.1 0.07 0.115 0.0352 0.13 -0.0316 0.325 0.218 0.165 0.198 0.0836 -0.112 -0.0897 -0.127 -0.249 0.112 -0.014 0.022 -0.2 -0.0196 -0.133 -0.153 -0.194 0.0032 0.0203 -0.178 -0.0414 -0.0648 -0.15 -0.102 -0.000385 -0.128 0.21 -0.166 -0.205 0.188 -0.246 -0.321 -0.0101 -0.164 0.0538 0.0198 0.239 -0.00341 0.41 #>  #> Status: Rvmminb appears to have converged summary(ARPM, lbfgsb2, lbfgsb2p, mix1, mix2, mix3, show_par = 1:3) #>          method elapsed   value   fn  gr alpha   beta  gamma1 #> ARPM       data      NA -186178   NA  NA 0.400 -0.400 -0.1253 #> lbfgsb2  Rvmmin   19.96 -186095 2701 425 0.397 -0.415 -0.0755 #> lbfgsb2p Rvmmin   16.16 -186095 2080 329 0.396 -0.415 -0.0743 #> mix1     Rvmmin   31.09 -186095 4011 590 0.396 -0.415 -0.0739 #> mix2     Rvmmin   33.79 -186095 4011 693 0.396 -0.415 -0.0740 #> mix3     Rvmmin    9.85 -186095  729 212 0.396 -0.415 -0.0746"},{"path":"https://roliveros-ramos.github.io/calibrar/articles/v03-parameter_estimation_ODE.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Parameter estimation for ODE systems","text":"vignette focus use calibrate() parameter estimation Ordinary Differential Equations (EDO) systems. suggest see vignette ‘Getting started calibrar package’ reading one, specially previous experience optimization R. Reading vignette ‘Using calibrate() function parameter estimation’ may also useful, every detail reproduced .","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/articles/v03-parameter_estimation_ODE.html","id":"fitting-an-edo-system-the-lotka-volterra-predator-prey-model","dir":"Articles","previous_headings":"","what":"Fitting an EDO system: the Lotka-Volterra Predator-Prey model","title":"Parameter estimation for ODE systems","text":"estimate parameters predator-prey Lotka-Volterra model using calibrate() function. model defined system ordinary differential equations abundance prey N predator P: \\frac{dN}{dt} = rN(1-N/K)-\\alpha NP \\frac{dP}{dt} = -lP + \\gamma\\alpha NP parameters estimate prey’s growth rate r, predator’s mortality rate l, carrying capacity prey K \\alpha \\gamma predation interaction. start, created demonstration data model using function calibrar_demo() function T=100 additional argument specify time horizon. run_model simulate data, solving ODE system defined Lotka-Volterra model: core run_model function relies solving ODE system using ode() function deSolve package. general, run_model takes par argument (can vector list) produce named list simulated data. intermediate code solves simulation problem taking set parameters produce numerical outputs simulated variable. also define objective function, based setup created demo: calibration_objFn() automatically create objective function following information setup, case, using log-normal distribution errors (type) weight . data expected read files file column, files created calling demo. Now can fit model using several optimization methods: compare : function created calibration_objFn() gains predict() method, can used simulate model estimated set parameters. plot results. <img src=“R:/sync/Github/calibrar/docs/articles/v03-parameter_estimation_ODE_files/figure-html/unnamed-chunk-8-1.png” alt=“Results calibration using ”L-BFGS-B”, “AHR-ES” “Nelder-Mead” methods.” width=“768” /> example, ‘L-BFGS-B’ ‘AHR-ES’ algorithms able estimate original parameter values, ‘Nelder-Mead’ algorithm .","code":"library(calibrar) set.seed(880820) path = NULL # NULL to use the current directory LV = calibrar_demo(path=path, model='PredatorPrey', T=100) ## Creating observed data list for calibration... ## Loaded observed data for variables: 'prey', 'predator'. setup = calibration_setup(file = LV$setup) observed = calibration_data(setup=setup, path=LV$path) ## Creating observed data list for calibration... ##  ## Loaded observed data for variables: 'prey', 'predator'. run_model = calibrar:::.PredatorPreyModel coef(LV) ## $r ## [1] 0.5 ##  ## $l ## [1] 0.2 ##  ## $K ## [1] 100 ##  ## $alpha ## [1] 0.1 ##  ## $gamma ## [1] 0.1 ##  ## $initial ## $initial$N ## [1] 10 ##  ## $initial$P ## [1] 1 run_model = function(par, T) {   if(!requireNamespace(\"deSolve\", quietly = TRUE))      stop(\"You need to install the 'deSolve' package.\")   # par is a list with 'alpha', 'beta' 'gamma', 'sd' and 'mu_ini'.   LV = function(t, y, parms, ...) {     r = parms$r     l = parms$l     alpha = parms$alpha     gamma = parms$gamma     K = parms$K     dN = r*y[1]*(1-(y[1]/K)) - alpha*y[1]*y[2]     dP = -l*y[2] + gamma*alpha*y[1]*y[2]     return(list(c(dN, dP)))   }   times = seq(0, T)   y0 = c(par$initial$N, par$initial$P)   sol = deSolve::ode(y=y0, times=times, func=LV, parms=par, method=\"ode45\")   out = as.list(as.data.frame(sol[,-1]))   names(out) = c(\"prey\", \"predator\")   out$prey[is.na(out$prey)] = 0   out$predator[is.na(out$predator)] = 0   return(out) } # objective functions obj = calibration_objFn(model=run_model, setup=setup, observed=observed, T=LV$T, aggregate=TRUE) lbfgsb1 = calibrate(par=LV$guess, fn=obj, method='L-BFGS-B', lower=LV$lower, upper=LV$upper, phases=LV$phase) ## Using optimization method 'L-BFGS-B'. ## Elapsed time: 2.37s ## Function value: 5.60587e-07 ## Parameter values: 0.5 0.2 100 0.1 0.1 ##  ## Status: CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH lbfgsb2 = calibrate(par=LV$guess, fn=obj, method=\"Rvmmin\", lower=LV$lower, upper=LV$upper, phases=LV$phase) ## Using optimization method 'Rvmmin'. ## Elapsed time: 2.98s ## Function value: 5.60575e-07 ## Parameter values: 0.5 0.2 100 0.1 0.1 ##  ## Status: Rvmminb appears to have converged ahr = calibrate(par=LV$guess, fn=obj, method='AHR-ES', lower=LV$lower, upper=LV$upper, phases=LV$phase) ## Using optimization method 'AHR-ES'. ## Elapsed time: 3m 17.6s ## Function value: 5.60575e-07 ## Parameter values: 0.5 0.2 100 0.1 0.1 ##  ## Status: Stopping criteria reached in 4909 generations. nm = calibrate(par=LV$guess, fn=obj, method=\"Nelder-Mead\", phases=LV$phase) ## Using optimization method 'Nelder-Mead'. ## Elapsed time: 48.86s ## Function value: 1.41517 ## Parameter values: 0.45 0.275 66.2 0.0788 0.183 ##  ## Status: - summary(LV, lbfgsb1, lbfgsb2, ahr, nm, show_par = 1:5) ##              method elapsed    value    fn gr    r     l     K  alpha gamma ## LV             data      NA 4.96e-07    NA NA 0.50 0.200 100.0 0.1000 0.100 ## lbfgsb1    L-BFGS-B    2.38 5.61e-07    74 74 0.50 0.200 100.0 0.1000 0.100 ## lbfgsb2      Rvmmin    2.98 5.61e-07   132 83 0.50 0.200 100.0 0.1000 0.100 ## ahr          AHR-ES  197.61 5.61e-07 39272  0 0.50 0.200 100.0 0.1000 0.100 ## nm      Nelder-Mead   48.86 1.42e+00   502 NA 0.45 0.275  66.2 0.0788 0.183 lbfgsb1.pred = predict(lbfgsb1) lbfgsb2.pred = predict(lbfgsb2) ahr.pred     = predict(ahr) nm.pred      = predict(nm) methods = c(\"data\", \"L-BFGS-B\", \"AHR-ES\", \"Nelder-Mead\") par(mfrow=c(1,2), mar=c(4,4,1,1),     oma=c(1,1,1,1)) plot(observed$prey, cex=0.75,      ylab=\"prey abundance (N)\", xlab=\"time\", las=1,      ylim=c(0,55)) lines(lbfgsb1.pred$prey, col=1, lwd=4) lines(ahr.pred$prey, col=2, lwd=2) lines(nm.pred$prey, col=3, lwd=2)  plot(observed$predator, cex=0.75,       ylab=\"predator abundance (P)\", xlab=\"time\", las=1,      ylim=c(0,7)) lines(lbfgsb1.pred$predator, col=1, lwd=4) lines(ahr.pred$predator, col=2, lwd=2) lines(nm.pred$predator, col=3, lwd=2)  legend(100, 1.8, legend=methods, bty=\"n\", cex=0.75, y.intersp=0.8,         inset=-0.0, xjust=1, pch = c(1, rep(NA,5)), lty=c(0, rep(1,5)),         col=c(1,1:3), lwd=2)"},{"path":"https://roliveros-ramos.github.io/calibrar/articles/v03-parameter_estimation_ODE.html","id":"fitting-an-edo-system-the-sir-epidemiological-model","dir":"Articles","previous_headings":"","what":"Fitting an EDO system: the SIR epidemiological model","title":"Parameter estimation for ODE systems","text":"second example, estimate parameters SIR epidemiological model. model defined system ordinary differential equations number susceptible S, infected recovered R individuals: \\frac{dS}{dt} = -\\beta S /N \\frac{dI}{dt} = \\beta S /N -\\gamma \\frac{dR}{dt} = \\gamma parameters estimate average number contacts per person per time \\beta instant probability infectious individual recovering \\gamma. start, created demonstration data model using function calibrar_demo() function T=100 additional argument specify time horizon. simulate model, create function taking vector list parameters par, solves EDO system return list simulated variables (S, , R): previous example, objective function created based run_model() function information setup table created demo: Now, can try several optimization algorithms estimate parameters model: compare : example, algorithms ‘Rvmmin’, ‘AHR-ES’, ‘Rcgmin’ ‘Nelder-Mead’ able estimate original parameters, ‘LBFGSB3’ fails. Please, refer vignette(package=\"calibrar\") additional vignettes calibrar website details.","code":"path = NULL # NULL to use the current directory SIR = calibrar_demo(path=path, model='SIR', T=100) ## Creating observed data list for calibration... ## Loaded observed data for variables: 'susceptible', 'infected', 'recovered'. setup = calibration_setup(file = SIR$setup) observed = calibration_data(setup=setup, path=SIR$path) ## Creating observed data list for calibration... ##  ## Loaded observed data for variables: 'susceptible', 'infected', 'recovered'. run_model = calibrar:::.SIRModel run_model = function(par, T) {   if(!requireNamespace(\"deSolve\", quietly = TRUE))     stop(\"You need to install the 'deSolve' package.\")   # par is a list with 'alpha', 'beta' 'gamma', 'sd' and 'mu_ini'.   SIR = function(t, y, parms, ...) {     N = sum(unlist(parms$initial))     beta = parms$beta     gamma = parms$gamma     S = y[1]     I = y[2]     dS = -beta*S*I/N     dI = +beta*S*I/N -gamma*I     dR = +gamma*I     return(list(c(dS, dI, dR)))   }   times = seq(0, T)   y0 = c(par$initial$S, par$initial$I, par$initial$R)   sol = deSolve::ode(y=y0, times=times, func=SIR, parms=par, method=\"ode45\")   out = as.list(as.data.frame(sol[,-1]))   names(out) = c(\"susceptible\", \"infected\", \"recovered\")   out$susceptible[is.na(out$susceptible)] = 0   out$infected[is.na(out$infected)] = 0   out$recovered[is.na(out$recovered)] = 0   return(out) } obj = calibration_objFn(model=run_model, setup=setup, observed=observed, T=SIR$T, aggregate=TRUE) lbfgsb3 = calibrate(par=SIR$guess, fn=obj, method='LBFGSB3', lower=SIR$lower, upper=SIR$upper, phases=SIR$phase) ## Using optimization method 'LBFGSB3'. ## Elapsed time: 1.11s ## Function value: 7.57138e-13 ## Parameter values: 0.4 0.2 ##  ## Status: CONVERGENCE: Parameters differences below xtol lbfgsb2 = calibrate(par=SIR$guess, fn=obj, method='Rvmmin', lower=SIR$lower, upper=SIR$upper, phases=SIR$phase) ## Using optimization method 'Rvmmin'. ## Elapsed time: 0.31s ## Function value: 7.56969e-13 ## Parameter values: 0.4 0.2 ##  ## Status: Rvmminb appears to have converged ahr = calibrate(par=SIR$guess, fn=obj, method='AHR-ES', lower=SIR$lower, upper=SIR$upper, phases=SIR$phase) ## Using optimization method 'AHR-ES'. ## Elapsed time: 28.14s ## Function value: 9.62938e-22 ## Parameter values: 0.4 0.2 ##  ## Status: Stopping criteria reached in 1031 generations. cg = calibrate(par=SIR$guess, fn=obj, method='Rcgmin', phases=SIR$phase) ## Using optimization method 'Rcgmin'. ## Elapsed time: 2m 26.4s ## Function value: 1.42228e-14 ## Parameter values: 0.4 0.2 ##  ## Status: Rcgmin seems to have converged nm = calibrate(par=SIR$guess, fn=obj, method='Nelder-Mead', phases=SIR$phase) ## Using optimization method 'Nelder-Mead'. ## Elapsed time: 0.33s ## Function value: 2.5122e-05 ## Parameter values: 0.4 0.2 ##  ## Status: - summary(SIR, lbfgsb2, lbfgsb3, ahr, cg, nm, show_par = 1:2) ##              method elapsed    value   fn gr beta gamma ## SIR            data      NA 4.45e-28   NA NA  0.4   0.2 ## lbfgsb2      Rvmmin   0.312 7.57e-13   24 16  0.4   0.2 ## lbfgsb3     LBFGSB3   1.108 7.57e-13   24 24  0.4   0.2 ## ahr          AHR-ES  28.140 9.63e-22 6186  0  0.4   0.2 ## cg           Rcgmin 146.391 1.42e-14   69 26  0.4   0.2 ## nm      Nelder-Mead   0.327 2.51e-05   73 NA  0.4   0.2"},{"path":"https://roliveros-ramos.github.io/calibrar/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Ricardo Oliveros-Ramos. Author, maintainer.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Oliveros–Ramos R, Shin Y (2025). “calibrar: R package fitting complex ecological models.” Methods Ecology Evolution. https://doi.org/10.1111/2041-210X.14452. Oliveros–Ramos R, Verley P, Echevin V, Shin Y (2017). “sequential approach calibrate ecosystem models multiple time series data.” Progress Oceanography, 151, 227-244. ISSN 0079-6611, https://doi.org/10.1016/j.pocean.2017.01.002.","code":"@Article{,   title = {calibrar: An R package for fitting complex ecological models},   journal = {Methods in Ecology and Evolution},   author = {Ricardo Oliveros--Ramos and Yunne--Jai Shin},   year = {2025},   abstract = {The fitting or parameter estimation of complex ecological models is a challenging optimisation task, with a notable lack of tools for fitting complex, long runtime or stochastic models. calibrar is an R package that is dedicated to the fitting of complex models to data. It is a generic tool that can be used for any type of model, especially those with non-differentiable objective functions and long runtime, including individual or agent based models. calibrar supports multiple phases and constrained optimisation, includes 20 optimisation algorithms, including derivative-based and heuristic ones. It supports any type of parallelisation, the capability to restart interrupted optimisations for long runtime models and the combination of different optimisation methods during the multiple phases of a calibration. User-level expertise in R is necessary to handle calibration experiments with calibrar, but there is no need to modify the model's code, which can be programmed in any language. It implements maximum likelihood estimation methods and automated construction of the objective function from simulated model outputs. For more experienced users, calibrar allows the implementation of user-defined objective functions. The package source code is fully accessible and can be installed directly from CRAN.},   url = {https://doi.org/10.1111/2041-210X.14452}, } @Article{,   title = {A sequential approach to calibrate ecosystem models with multiple time series data},   journal = {Progress in Oceanography},   volume = {151},   pages = {227-244},   year = {2017},   issn = {0079-6611},   url = {https://doi.org/10.1016/j.pocean.2017.01.002},   author = {Ricardo Oliveros--Ramos and Philippe Verley and Vincent Echevin and Yunne--Jai Shin},   abstract = {When models are aimed to support decision-making, their credibility is essential to consider. Model fitting to observed data is one major criterion to assess such credibility. However, due to the complexity of ecosystem models making their calibration more challenging, the scientific community has given more attention to the exploration of model behavior than to a rigorous comparison to observations. This work highlights some issues related to the comparison of complex ecosystem models to data and proposes a methodology for a sequential multi-phases calibration (or parameter estimation) of ecosystem models. We first propose two criteria to classify the parameters of a model: the model dependency and the time variability of the parameters. Then, these criteria and the availability of approximate initial estimates are used as decision rules to determine which parameters need to be estimated, and their precedence order in the sequential calibration process. The end-to-end (E2E) ecosystem model ROMS-PISCES-OSMOSE applied to the Northern Humboldt Current Ecosystem is used as an illustrative case study. The model is calibrated using an evolutionary algorithm and a likelihood approach to fit time series data of landings, abundance indices and catch at length distributions from 1992 to 2008. Testing different calibration schemes regarding the number of phases, the precedence of the parameters' estimation, and the consideration of time varying parameters, the results show that the multiple-phase calibration conducted under our criteria allowed to improve the model fit.}, }"},{"path":[]},{"path":"https://roliveros-ramos.github.io/calibrar/index.html","id":"automated-parameter-estimation-for-complex-models","dir":"","previous_headings":"","what":"Automated Parameter Estimation for Complex Models","title":"Automated Parameter Estimation for Complex Models","text":"R package, calibrar, designed parameter estimation (calibration) wide range ecological models, including complex stochastic models. package combines various optimization functionalities single interface, enabling implementation latest advancements complex model calibration. package provides support multiple phases box constrained optimisation possibility using several algorithms available R. particular, using “black-box” approach, package allows calibration models implemented programming language. provides generic interface models allows construction objective function, within R, without requiring changes models’ code. Parallel support computationally intensive models also provided, can used high performance computing systems simple manner, including capability restart unfinished optimisation models long runtime. implements generic functions can used fitting type models, especially non-differentiable objective functions, syntax base::optim. supports multiple phases estimation (sequential parameter masking), constrained optimization (bounding box restrictions) automatic parallel computation numerical gradients. common maximum likelihood estimation methods automated construction objective function simulated model outputs provided. See https://roliveros-ramos.github.io/calibrar/ details.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Automated Parameter Estimation for Complex Models","text":"","code":"# The easiest way to get calibrar is to install it from CRAN: install.packages(\"calibrar\")  # Alternatively, install the stable development version from OSMOSE drat repository: install.packages(\"calibrar\", repo=\"https://osmose-model.github.io/drat/\")  # Or the development version from GitHub: # install.packages(\"remotes\") remotes::install_github(\"roliveros-ramos/calibrar\")"},{"path":"https://roliveros-ramos.github.io/calibrar/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Automated Parameter Estimation for Complex Models","text":"quick introduction, check worked examples available package: detailed explanation package philosophy, can read article calibrar: R package fitting complex ecological models.","code":"library(calibrar) vignette(\"calibrar\")"},{"path":"https://roliveros-ramos.github.io/calibrar/index.html","id":"contributions","dir":"","previous_headings":"","what":"Contributions","title":"Automated Parameter Estimation for Complex Models","text":"find bug, questions documentation requests enhancements, please open issue. Contributions accepted pull requests. Please note calibrar package released Contributor Code Conduct. contributing project, agree abide terms.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/ahres.html","id":null,"dir":"Reference","previous_headings":"","what":"Adaptative Hierarchical Recombination Evolutionary Strategy (AHR-ES) for derivative-free and black-box optimization — ahres","title":"Adaptative Hierarchical Recombination Evolutionary Strategy (AHR-ES) for derivative-free and black-box optimization — ahres","text":"function performs optimization function using Adaptative Hierarchical Recombination Evolutionary Strategy (AHR-ES, Oliveros & Shin, 2015).","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/ahres.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adaptative Hierarchical Recombination Evolutionary Strategy (AHR-ES) for derivative-free and black-box optimization — ahres","text":"","code":"ahres(   par,   fn,   gr = NULL,   ...,   lower = -Inf,   upper = +Inf,   active = NULL,   control = list(),   hessian = FALSE,   parallel = FALSE )"},{"path":"https://roliveros-ramos.github.io/calibrar/reference/ahres.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adaptative Hierarchical Recombination Evolutionary Strategy (AHR-ES) for derivative-free and black-box optimization — ahres","text":"par numeric vector list. length par argument defines number parameters estimated (.e. dimension problem). fn function minimized. gr function computing gradient fn. NULL, numerical approximation gradient used. can also character specifying method computation numerical gradient: 'central', 'forward' (default), 'backward' 'richardson'. ... Additional parameters passed fn. lower Lower threshold value(s) parameters. One value vector length par. one value provided, used parameters. NA means -Inf. default -Inf used (unconstrained). upper Upper threshold value(s) parameters. One value vector length par. one value provided, used parameters. NA means Inf. default Inf used (unconstrained). active Boolean vector length par, indicating parameter used optimization (TRUE) hold fixed value (FALSE). control Parameter control algorithm , see details. hessian Logical. numerically differentiated Hessian matrix returned? Currently implemented. parallel Logical. Use parallel computation numerical gradient?","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/ahres.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adaptative Hierarchical Recombination Evolutionary Strategy (AHR-ES) for derivative-free and black-box optimization — ahres","text":"list components: par best set parameters found. value value fn corresponding par. counts two-element integer vector giving number calls fn gr respectively. excludes calls needed compute Hessian, requested, calls fn compute finite-difference approximation gradient. convergence integer code. 0 indicates successful completion. message character string giving additional information returned optimizer, NULL. hessian argument hessian true. symmetric matrix giving estimate Hessian solution found. Note Hessian unconstrained problem even box constraints active.","code":""},{"path":[]},{"path":"https://roliveros-ramos.github.io/calibrar/reference/ahres.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Adaptative Hierarchical Recombination Evolutionary Strategy (AHR-ES) for derivative-free and black-box optimization — ahres","text":"Ricardo Oliveros-Ramos","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/ahres.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Adaptative Hierarchical Recombination Evolutionary Strategy (AHR-ES) for derivative-free and black-box optimization — ahres","text":"","code":"if (FALSE) ahres(par=rep(1, 5), fn=sphereN) # \\dontrun{}"},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibrar-defunct.html","id":null,"dir":"Reference","previous_headings":"","what":"Defunct functions in package calibrar. — calibrar-defunct","title":"Defunct functions in package calibrar. — calibrar-defunct","text":"functions listed defunct. possible, alternative functions similar   functionality also mentioned. Help pages defunct functions   available help(\"<function>-defunct\").","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibrar-defunct.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Defunct functions in package calibrar. — calibrar-defunct","text":"","code":"getObservedData(info, path, data.folder = \"data\", ...)  getCalibrationInfo(   path,   file = \"calibrationInfo.csv\",   stringsAsFactors = FALSE,   ... )  createObjectiveFunction(   runModel,   info,   observed,   aggFn = .weighted.sum,   aggregate = FALSE,   ... )"},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibrar-defunct.html","id":"getobserveddata","dir":"Reference","previous_headings":"","what":"getObservedData","title":"Defunct functions in package calibrar. — calibrar-defunct","text":"Deprecated v0.3, defunct v0.9. getObservedData, use calibration_data.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibrar-defunct.html","id":"getcalibrationinfo","dir":"Reference","previous_headings":"","what":"getCalibrationInfo","title":"Defunct functions in package calibrar. — calibrar-defunct","text":"Deprecated v0.3, defunct v0.9. getCalibrationInfo, use calibration_setup.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibrar-defunct.html","id":"createobjectivefunction","dir":"Reference","previous_headings":"","what":"createObjectiveFunction","title":"Defunct functions in package calibrar. — calibrar-defunct","text":"Deprecated v0.3, defunct v0.9. createObjectiveFunction, use calibration_objFn.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibrar-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Automated Calibration for Complex Models — calibrar-package","title":"Automated Calibration for Complex Models — calibrar-package","text":"Automated Calibration Complex Models","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibrar-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Automated Calibration for Complex Models — calibrar-package","text":"calibrar package: Automated Calibration Complex Models  package allows parameter estimation (.e. calibration) complex models, including stochastic ones. implements generic functions can used fitting type models, especially non-differentiable objective functions, syntax base::optim. supports multiple phases estimation (sequential parameter masking), constrained optimization (bounding box restrictions) automatic parallel computation numerical gradients. common maximum likelihood estimation methods automated construction objective function simulated model outputs provided. See <https://roliveros-ramos.github.io/calibrar/> details.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibrar-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Automated Calibration for Complex Models — calibrar-package","text":"calibrar: R package calibration ecological models (Oliveros-Ramos Shin 2014)","code":""},{"path":[]},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibrar-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Automated Calibration for Complex Models — calibrar-package","text":"Ricardo Oliveros-Ramos Maintainer: Ricardo Oliveros-Ramos <ricardo.oliveros@gmail.com>","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibrar-package.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Automated Calibration for Complex Models — calibrar-package","text":"","code":"if (FALSE) { # \\dontrun{ require(calibrar) set.seed(880820) path = NULL # NULL to use the current directory # create the demonstration files demo = calibrar_demo(model=\"PoissonMixedModel\", L=5, T=100)  # get calibration information calibrationInfo = calibration_setup(file=demo$path) # get observed data observed = calibration_data(setup=calibrationInfo, path=demo$path) # read forcings for the model forcing = read.csv(file.path(demo$path, \"master\", \"environment.csv\"), row.names=1) # Defining 'runModel' function runModel = function(par, forcing) { output = calibrar:::.PoissonMixedModel(par=par, forcing=forcing) # adding gamma parameters for penalties output = c(output, list(gammas=par$gamma))  return(output) } # real parameters cat(\"Real parameters used to simulate data\\n\") print(demo$par) # objective functions obj  = calibration_objFn(model=runModel, setup=calibrationInfo,                                 observed=observed, forcing=forcing) cat(\"Starting calibration...\\n\") control = list(weights=calibrationInfo$weights, maxit=3.6e5) # control parameters cat(\"Running optimization algorithms\\n\", \"\\t\", date(), \"\\n\") cat(\"Running optim AHR-ES\\n\") ahr = calibrate(par=demo$guess, fn=obj, lower=demo$lower, upper=demo$upper, control=control) summary(ahr) } # }"},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibrar_demo.html","id":null,"dir":"Reference","previous_headings":"","what":"Demos for the calibrar package — calibrar_demo","title":"Demos for the calibrar package — calibrar_demo","text":"Creates demo files able processed full calibration using calibrar package","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibrar_demo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Demos for the calibrar package — calibrar_demo","text":"","code":"calibrar_demo(path = NULL, model = NULL, ...)"},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibrar_demo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Demos for the calibrar package — calibrar_demo","text":"path Path create demo files model Model used demo files, see details. ... Additional parameters used construction demo files.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibrar_demo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Demos for the calibrar package — calibrar_demo","text":"list following elements: path Path files saved par Real value parameters used demo setup Path calibration setup file guess Values provided initial guess calibrate function lower Values provided lower bounds calibrate function upper Values provided upper bounds calibrate function phase Values provided phases calibrate function constants Constants used demo, variable listed . value NA, set compatibility summary methods. time NA, set compatibility summary methods. counts NA, set compatibility summary methods.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibrar_demo.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Demos for the calibrar package — calibrar_demo","text":"Current implemented models : PoissonMixedModel Poisson Autoregressive Mixed model dynamics population different sites: $$log(\\mu_{, t+1}) = log(\\mu_{, t}) + \\alpha + \\beta X_{, t} + \\gamma_t$$ \\(\\mu_{, t}\\) size population site \\(\\) year \\(t\\), \\(X_{, t}\\) value environmental variable site \\(\\) year \\(t\\). parameters estimate \\(\\alpha\\), \\(\\beta\\), \\(\\gamma_t\\), random effects year, \\(\\gamma_t \\sim N(0,\\sigma^2)\\), initial population site \\(\\mu_{, 0}\\). assumed observations \\(N_{,t}\\) follow Poisson distribution mean \\(\\mu_{, t}\\). PredatorPrey Lotka Volterra Predator-Prey model. model defined system ordinary differential equations abundance prey $N$ predator $P$: $$\\frac{dN}{dt} = rN(1-N/K)-\\alpha NP$$ $$\\frac{dP}{dt} = -lP + \\gamma\\alpha NP$$ parameters estimate prey’s growth rate \\(r\\), predator’s mortality rate \\(l\\), carrying capacity prey \\(K\\) \\(\\alpha\\) \\(\\gamma\\) predation interaction. Uses deSolve package numerical solution ODE system. SIR Susceptible-Infected-Recovered epidemiological model. model defined system ordinary differential equations number susceptible $S$, infected $$ recovered $R$ individuals: $$\\frac{dS}{dt} = -\\beta S /N$$ $$\\frac{dI}{dt} = \\beta S /N -\\gamma $$ $$\\frac{dR}{dt} = \\gamma $$ parameters estimate  average number contacts per person per time \\(\\beta\\) instant probability infectious individual recovering \\(\\gamma\\). Uses deSolve package numerical solution ODE system. IBMLotkaVolterra Stochastic Individual Based Model Lotka-Volterra model. Uses ibm package simulation.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibrar_demo.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Demos for the calibrar package — calibrar_demo","text":"Oliveros-Ramos Shin (2014)","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibrar_demo.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Demos for the calibrar package — calibrar_demo","text":"Ricardo Oliveros–Ramos","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibrar_demo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Demos for the calibrar package — calibrar_demo","text":"","code":"if (FALSE) { # \\dontrun{  summary(ahr) set.seed(880820) path = NULL # NULL to use the current directory # create the demonstration files demo = calibrar_demo(path=path, model=\"PredatorPrey\", T=100)  # get calibration information calibration_settings = calibration_setup(file = demo$setup) # get observed data observed = calibration_data(setup = calibration_settings, path=demo$path) # Defining 'run_model' function run_model = calibrar:::.PredatorPreyModel # real parameters cat(\"Real parameters used to simulate data\\n\") print(unlist(demo$par)) # parameters are in a list # objective functions obj  = calibration_objFn(model=run_model, setup=calibration_settings, observed=observed, T=demo$T) obj2 = calibration_objFn(model=run_model, setup=calibration_settings, observed=observed,  T=demo$T, aggregate=TRUE) cat(\"Starting calibration...\\n\") cat(\"Running optimization algorithms\\n\", \"\\t\") cat(\"Running optim AHR-ES\\n\") ahr = calibrate(par=demo$guess, fn=obj, lower=demo$lower, upper=demo$upper, phases=demo$phase) summary(ahr) } # }"},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibrate.html","id":null,"dir":"Reference","previous_headings":"","what":"Sequential parameter estimation for the calibration of complex models — calibrate","title":"Sequential parameter estimation for the calibration of complex models — calibrate","text":"function performs optimization function, possibly sequential phases increasing complexity, designed calibration model, minimizing error function fn associated .","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibrate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sequential parameter estimation for the calibration of complex models — calibrate","text":"","code":"calibrate(   par,   fn,   gr,   ...,   method,   lower,   upper,   phases,   control,   hessian,   replicates,   parallel )  # Default S3 method calibrate(   par,   fn,   gr = NULL,   ...,   method = NULL,   lower = NULL,   upper = NULL,   phases = NULL,   control = list(),   hessian = FALSE,   replicates = 1,   parallel = FALSE )"},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibrate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sequential parameter estimation for the calibration of complex models — calibrate","text":"par numeric vector list. length par argument defines number parameters estimated (.e. dimension problem). fn function minimized. gr function computing gradient fn. NULL, numerical approximation gradient used. can also character specifying method computation numerical gradient: 'central', 'forward' (default), 'backward' 'richardson'. ... Additional parameters passed fn. method optimization method used. default method AHR-ES (Adaptative Hierarchical Recombination Evolutionary Strategy, Oliveros-Ramos & Shin, 2016). See details methods available. lower Lower threshold value(s) parameters. One value vector length par. one value provided, used parameters. NA means -Inf. default -Inf used (unconstrained). upper Upper threshold value(s) parameters. One value vector length par. one value provided, used parameters. NA means Inf. default Inf used (unconstrained). phases optional vector length par, indicating phase parameter becomes active. omitted, default value 1 parameters, performing single optimization. control Parameter control algorithm , see details. hessian Logical. numerically differentiated Hessian matrix returned? Currently implemented. replicates number replicates evaluation fn. default value 1. value greater 1 useful stochastic functions. parallel Logical. Use parallel computation numerical gradient?","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibrate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sequential parameter estimation for the calibration of complex models — calibrate","text":"control list, aggFn function aggregate fn scalar value returned value vector. optimization algorithm can exploite additional information provided vectorial output fn.","code":""},{"path":[]},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibrate.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Sequential parameter estimation for the calibration of complex models — calibrate","text":"Ricardo Oliveros-Ramos","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibrate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sequential parameter estimation for the calibration of complex models — calibrate","text":"","code":"calibrate(par=rep(NA, 5), fn=sphereN) #> Using optimization method 'Rvmmin'. #> Elapsed time: 0.01s #> Function value: 0.0258772 #> Parameter values: -1e-04 -1.24e-06 -4.34e-05 3.22e-05 4.01e-05 #>  #> Status: Rvmminu appears to have converged #> Optimization using 'Rvmmin' algorithm. #> Function value: 0.02587717  #> Status: Rvmminu appears to have converged  #> Parameters: #> [1] -9.996345e-05 -1.240568e-06 -4.341452e-05  3.218151e-05  4.013083e-05 #> Computation: #> function gradient  #>       54        2  if (FALSE) { # \\dontrun{ calibrate(par=rep(NA, 5), fn=sphereN, replicates=3) calibrate(par=rep(0.5, 5), fn=sphereN, replicates=3, lower=-5, upper=5) calibrate(par=rep(0.5, 5), fn=sphereN, replicates=3, lower=-5, upper=5, phases=c(1,1,1,2,3)) calibrate(par=rep(0.5, 5), fn=sphereN, replicates=c(1,1,4), lower=-5, upper=5, phases=c(1,1,1,2,3)) } # }"},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibration_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Get observed data for the calibration of a model — calibration_data","title":"Get observed data for the calibration of a model — calibration_data","text":"Create list observed data information provided main argument.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibration_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get observed data for the calibration of a model — calibration_data","text":"","code":"calibration_data(setup, path = \".\", file = NULL, verbose = TRUE, ...)"},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibration_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get observed data for the calibration of a model — calibration_data","text":"setup data.frame information calibration, normally created calibration_setup function. See details. path Path directory look data. Paths setup considered relatives path. file Optional file save created object ('rds' file.) verbose TRUE, detailed messages process printed. ... Additional arguments read.csv function read data files.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibration_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get observed data for the calibration of a model — calibration_data","text":"list observed data needed calibration, used combination calibration_objFn.","code":""},{"path":[]},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibration_data.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Get observed data for the calibration of a model — calibration_data","text":"Ricardo Oliveros-Ramos","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibration_objFn.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an objective function to be used with optimization routines — calibration_objFn","title":"Create an objective function to be used with optimization routines — calibration_objFn","text":"Create new function, used objective function calibration, given function run model within R, observed data information comparison data.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibration_objFn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an objective function to be used with optimization routines — calibration_objFn","text":"","code":"calibration_objFn(model, setup, observed, aggFn = NULL, aggregate = FALSE, ...)"},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibration_objFn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an objective function to be used with optimization routines — calibration_objFn","text":"model Function run model produce list outputs. setup data.frame information calibration, normally created calibration_setup function. See details. observed list observed variables created function calibration_data aggFn function aggregate fn scalar value returned value vector. optimization algorithm can explote additional information provided vectorial output fn aggregate boolean, TRUE, scalar value returned using aggFn. ... arguments passed model function.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibration_objFn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an objective function to be used with optimization routines — calibration_objFn","text":"function, integrating simulation model comparison observed data.","code":""},{"path":[]},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibration_objFn.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create an objective function to be used with optimization routines — calibration_objFn","text":"Ricardo Oliveros-Ramos","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibration_setup.html","id":null,"dir":"Reference","previous_headings":"","what":"Get information to run a calibration using the calibrar package. — calibration_setup","title":"Get information to run a calibration using the calibrar package. — calibration_setup","text":"wrapper read.csv checking column names data types table calibration information.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibration_setup.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get information to run a calibration using the calibrar package. — calibration_setup","text":"","code":"calibration_setup(file, control = list(), ...)"},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibration_setup.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get information to run a calibration using the calibrar package. — calibration_setup","text":"file file calibration information, see details. control Control arguments generating setup. See details. ... Additional arguments read.csv function.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibration_setup.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get information to run a calibration using the calibrar package. — calibration_setup","text":"data.frame information calibration model, used calibration_objFn calibration_data.","code":""},{"path":[]},{"path":"https://roliveros-ramos.github.io/calibrar/reference/calibration_setup.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Get information to run a calibration using the calibrar package. — calibration_setup","text":"Ricardo Oliveros-Ramos","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/createObjectiveFunction-defunct.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an objective function to be used with optimization routines — createObjectiveFunction-defunct","title":"Create an objective function to be used with optimization routines — createObjectiveFunction-defunct","text":"Create new function, used objective function calibration, given function run model within R, observed data information comparison data.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/createObjectiveFunction-defunct.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an objective function to be used with optimization routines — createObjectiveFunction-defunct","text":"runModel Function run model produce list outputs. info data.frame information calibration, normally created getCalibrationInfo function. See details. observed list observed variables created function getObservedData aggFn function aggregate fn scalar value returned value vector. optimization algorithm can explote additional information provided vectorial output fn aggregate boolean, TRUE, scalar value returned using aggFn. ... arguments passed runModel function.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/createObjectiveFunction-defunct.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an objective function to be used with optimization routines — createObjectiveFunction-defunct","text":"function, integrating simulation model comparison observed data.","code":""},{"path":[]},{"path":"https://roliveros-ramos.github.io/calibrar/reference/createObjectiveFunction-defunct.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create an objective function to be used with optimization routines — createObjectiveFunction-defunct","text":"Ricardo Oliveros-Ramos","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/dot-get_command_argument.html","id":null,"dir":"Reference","previous_headings":"","what":"Get an specific argument from the command line — .get_command_argument","title":"Get an specific argument from the command line — .get_command_argument","text":"Get specific argument command line","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/dot-get_command_argument.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get an specific argument from the command line — .get_command_argument","text":"","code":".get_command_argument(   x,   argument,   prefix = \"--\",   default = FALSE,   verbose = FALSE )"},{"path":"https://roliveros-ramos.github.io/calibrar/reference/dot-get_command_argument.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get an specific argument from the command line — .get_command_argument","text":"x command line arguments, x = commandArgs() argument name argument. prefix prefix argument interest, default \"–\" default Default value return argument missing, default FALSE. verbose Boolean, TRUE, shows warning parameter found.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/dot-get_command_argument.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get an specific argument from the command line — .get_command_argument","text":"value argument, assumed followed '=' , TRUE nothing argument found. argument found, FALSE returned.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/dot-get_command_argument.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get an specific argument from the command line — .get_command_argument","text":"","code":".get_command_argument(commandArgs(), \"interactive\") #> [1] FALSE .get_command_argument(commandArgs(), \"RStudio\") #> [1] FALSE .get_command_argument(commandArgs(), \"RStudio\", prefix=\"\") #> [1] FALSE .get_command_argument(commandArgs(), \"vanilla\") #> [1] FALSE .get_command_argument(\"--control.file=baz.txt\", \"control.file\") #> [1] \"baz.txt\""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/dot-read_configuration.html","id":null,"dir":"Reference","previous_headings":"","what":"Read a configuration file. — .read_configuration","title":"Read a configuration file. — .read_configuration","text":"File expected lines form 'key SEP value' key name parameter, SEP separator (can '=' ',', ';') value value parameter . SEP line determined parameters values returned list.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/dot-read_configuration.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read a configuration file. — .read_configuration","text":"","code":".read_configuration(   file,   recursive = TRUE,   keep.names = TRUE,   conf.key = NULL,   ... )"},{"path":"https://roliveros-ramos.github.io/calibrar/reference/dot-read_configuration.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read a configuration file. — .read_configuration","text":"file File read configuration recursive 'conf.key' keys read additional configuration files? Default TRUE. keep.names names kept ? default, converted lower case. conf.key String indicating leading key find additional configuration file. ... Additional arguments, currently use.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/gaussian_kernel.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate a discretization of the 2D Gaussian Kernel — gaussian_kernel","title":"Calculate a discretization of the 2D Gaussian Kernel — gaussian_kernel","text":"Calculate discretization 2D Gaussian Kernel","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/gaussian_kernel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate a discretization of the 2D Gaussian Kernel — gaussian_kernel","text":"","code":"gaussian_kernel(par, lower, upper, n = 10, checkSymmetry = TRUE, ...)"},{"path":"https://roliveros-ramos.github.io/calibrar/reference/gaussian_kernel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate a discretization of the 2D Gaussian Kernel — gaussian_kernel","text":"par list, including mean covariance matrix. lower vector, indicating lower bound calculation. upper vector, indicating upper bound calculation. n number cells dimension, can one two numbers. checkSymmetry TRUE default, checks covariance matrix symmetric. ... Additional arguments, currently used.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/gaussian_kernel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate a discretization of the 2D Gaussian Kernel — gaussian_kernel","text":"list, 'x', 'y' 'z' components.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/getCalibrationInfo-defunct.html","id":null,"dir":"Reference","previous_headings":"","what":"Get information to run a calibration using the calibrar package. — getCalibrationInfo-defunct","title":"Get information to run a calibration using the calibrar package. — getCalibrationInfo-defunct","text":"wrapper read.csv checking column names data types table calibration information.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/getCalibrationInfo-defunct.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get information to run a calibration using the calibrar package. — getCalibrationInfo-defunct","text":"path path look file. file file calibration information, see details. stringsAsFactors passed read.csv. ... Additional arguments read.csv function.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/getCalibrationInfo-defunct.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get information to run a calibration using the calibrar package. — getCalibrationInfo-defunct","text":"data.frame information calibration model, used createObjectiveFunction getObservedData.","code":""},{"path":[]},{"path":"https://roliveros-ramos.github.io/calibrar/reference/getCalibrationInfo-defunct.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Get information to run a calibration using the calibrar package. — getCalibrationInfo-defunct","text":"Ricardo Oliveros-Ramos","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/getObservedData-defunct.html","id":null,"dir":"Reference","previous_headings":"","what":"Get observed data for the calibration of a model — getObservedData-defunct","title":"Get observed data for the calibration of a model — getObservedData-defunct","text":"Create list observed data information provided main argument.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/getObservedData-defunct.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get observed data for the calibration of a model — getObservedData-defunct","text":"info data.frame information calibration, normally created getCalibrationInfo function. See details. path Path directory look data. data.folder folder path containing data. ... Additional arguments read.csv function read data files.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/getObservedData-defunct.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get observed data for the calibration of a model — getObservedData-defunct","text":"list observed data needed calibration, used combination createObjectiveFunction.","code":""},{"path":[]},{"path":"https://roliveros-ramos.github.io/calibrar/reference/getObservedData-defunct.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Get observed data for the calibration of a model — getObservedData-defunct","text":"Ricardo Oliveros-Ramos","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/gradient.html","id":null,"dir":"Reference","previous_headings":"","what":"Numerical computation of the gradient, with parallel capabilities — gradient","title":"Numerical computation of the gradient, with parallel capabilities — gradient","text":"function calculates gradient function, numerically, including possibility parallel.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/gradient.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Numerical computation of the gradient, with parallel capabilities — gradient","text":"","code":"gradient(fn, x, method, control, parallel, ...)"},{"path":"https://roliveros-ramos.github.io/calibrar/reference/gradient.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Numerical computation of the gradient, with parallel capabilities — gradient","text":"fn function calculate gradient. x value compute gradient . method method used. Currently implemented: central, backward, forward Richardson. See details. control list control arguments. parallel Boolean, numerical derivatives calculated parallel? ... Additional arguments passed fn.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/gradient.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Numerical computation of the gradient, with parallel capabilities — gradient","text":"gradient fn x.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/gradient.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Numerical computation of the gradient, with parallel capabilities — gradient","text":"","code":"gradient(fn=function(x) sum(x^3), x=0) #> [1] 1e-16"},{"path":"https://roliveros-ramos.github.io/calibrar/reference/objFn.html","id":null,"dir":"Reference","previous_headings":"","what":"Calcuted error measure between observed and simulated data — objFn","title":"Calcuted error measure between observed and simulated data — objFn","text":"Calcuted error measure observed simulated data","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/objFn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calcuted error measure between observed and simulated data — objFn","text":"","code":"objFn(obs, sim, FUN, ...)  fitness(obs, sim, FUN, ...)"},{"path":"https://roliveros-ramos.github.io/calibrar/reference/objFn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calcuted error measure between observed and simulated data — objFn","text":"obs observed data expected FUN. sim simulated data matching 'obs' FUN error function. Current accepted values area: 'norm2', 'lnorm2', 'lnorm3', 'multinomial', 'pois', 'penalty0', 'penalty1', 'penalty2' 'normp'. ... Additional arguments FUN","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/objFn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calcuted error measure between observed and simulated data — objFn","text":"value FUN(obs, sim, ...)","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/optim2.html","id":null,"dir":"Reference","previous_headings":"","what":"General-purpose optimization with parallel numerical gradient computation — optim2","title":"General-purpose optimization with parallel numerical gradient computation — optim2","text":"General-purpose optimization parallel numerical gradient computation","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/optim2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"General-purpose optimization with parallel numerical gradient computation — optim2","text":"","code":"optim2(   par,   fn,   gr = NULL,   ...,   method = c(\"Nelder-Mead\", \"BFGS\", \"CG\", \"L-BFGS-B\", \"SANN\", \"Brent\", \"nlm\", \"nlminb\",     \"Rcgmin\", \"Rvmmin\", \"hjn\", \"spg\", \"LBFGSB3\", \"AHR-ES\"),   lower = -Inf,   upper = +Inf,   active = NULL,   control = list(),   hessian = FALSE,   parallel = FALSE )"},{"path":"https://roliveros-ramos.github.io/calibrar/reference/optim2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"General-purpose optimization with parallel numerical gradient computation — optim2","text":"par numeric vector list. length par argument defines number parameters estimated (.e. dimension problem). fn function minimized. gr function computing gradient fn. NULL, numerical approximation gradient used. can also character specifying method computation numerical gradient: 'central', 'forward' (default), 'backward' 'richardson'. ... Additional parameters passed fn. method optimization method used. default method AHR-ES (Adaptative Hierarchical Recombination Evolutionary Strategy, Oliveros-Ramos & Shin, 2016). See details methods available. lower Lower threshold value(s) parameters. One value vector length par. one value provided, used parameters. NA means -Inf. default -Inf used (unconstrained). upper Upper threshold value(s) parameters. One value vector length par. one value provided, used parameters. NA means Inf. default Inf used (unconstrained). active Boolean vector length par, indicating parameter used optimization (TRUE) hold fixed value (FALSE). control Parameter control algorithm , see details. hessian Logical. numerically differentiated Hessian matrix returned? Currently implemented. parallel Logical. Use parallel computation numerical gradient?","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/optim2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"General-purpose optimization with parallel numerical gradient computation — optim2","text":"list components: par best set parameters found. value value fn corresponding par. counts two-element integer vector giving number calls fn gr respectively. excludes calls needed compute Hessian, requested, calls fn compute finite-difference approximation gradient. convergence integer code. 0 indicates successful completion. message character string giving additional information returned optimizer, NULL. hessian argument hessian true. symmetric matrix giving estimate Hessian solution found. Note Hessian unconstrained problem even box constraints active.","code":""},{"path":[]},{"path":"https://roliveros-ramos.github.io/calibrar/reference/optim2.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"General-purpose optimization with parallel numerical gradient computation — optim2","text":"Ricardo Oliveros-Ramos","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/optim2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"General-purpose optimization with parallel numerical gradient computation — optim2","text":"","code":"optim2(par=rep(NA, 5), fn=sphereN) #> $par #> [1] -0.003853539 -0.030986287  0.060781610 -0.040176383  0.060071570 #>  #> $value #> [1] 0.003254764 #>  #> $counts #> function gradient  #>      505       NA  #>  #> $convergence #> [1] 1 #>  #> $message #> NULL #>"},{"path":"https://roliveros-ramos.github.io/calibrar/reference/optimh.html","id":null,"dir":"Reference","previous_headings":"","what":"General-purpose optimization using heuristic algorithms — optimh","title":"General-purpose optimization using heuristic algorithms — optimh","text":"General-purpose optimization using heuristic algorithms","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/optimh.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"General-purpose optimization using heuristic algorithms — optimh","text":"","code":"optimh(   par,   fn,   gr = NULL,   ...,   method = c(\"AHR-ES\", \"Nelder-Mead\", \"SANN\", \"hjn\", \"bobyqa\", \"CMA-ES\", \"genSA\", \"DE\",     \"soma\", \"genoud\", \"PSO\", \"hybridPSO\", \"mads\", \"hjk\", \"hjkb\", \"nmk\", \"nmkb\"),   lower = -Inf,   upper = +Inf,   active = NULL,   control = list(),   hessian = FALSE,   parallel = FALSE )"},{"path":"https://roliveros-ramos.github.io/calibrar/reference/optimh.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"General-purpose optimization using heuristic algorithms — optimh","text":"par numeric vector list. length par argument defines number parameters estimated (.e. dimension problem). fn function minimized. gr Function compute gradient fn. Ignored methods, added consistency optimization functions. ... Additional parameters passed fn. method optimization method used. default method AHR-ES (Adaptative Hierarchical Recombination Evolutionary Strategy, Oliveros-Ramos & Shin, 2016). See details methods available. lower Lower threshold value(s) parameters. One value vector length par. one value provided, used parameters. NA means -Inf. default -Inf used (unconstrained). upper Upper threshold value(s) parameters. One value vector length par. one value provided, used parameters. NA means Inf. default Inf used (unconstrained). active Boolean vector length par, indicating parameter used optimization (TRUE) hold fixed value (FALSE). control Parameter control algorithm , see details. hessian Logical. numerically differentiated Hessian matrix returned? Currently implemented. parallel Logical. Use parallel computation numerical gradient?","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/optimh.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"General-purpose optimization using heuristic algorithms — optimh","text":"list components: par best set parameters found. value value fn corresponding par. counts two-element integer vector giving number calls fn gr respectively. excludes calls needed compute Hessian, requested, calls fn compute finite-difference approximation gradient. convergence integer code. 0 indicates successful completion. message character string giving additional information returned optimizer, NULL. hessian argument hessian true. symmetric matrix giving estimate Hessian solution found. Note Hessian unconstrained problem even box constraints active.","code":""},{"path":[]},{"path":"https://roliveros-ramos.github.io/calibrar/reference/optimh.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"General-purpose optimization using heuristic algorithms — optimh","text":"Ricardo Oliveros-Ramos","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/optimh.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"General-purpose optimization using heuristic algorithms — optimh","text":"","code":"optim2(par=rep(NA, 5), fn=sphereN) #> $par #> [1] -0.003724125 -0.005021691  0.001150144  0.090722235  0.015722235 #>  #> $value #> [1] 0.00527852 #>  #> $counts #> function gradient  #>      504       NA  #>  #> $convergence #> [1] 1 #>  #> $message #> NULL #>"},{"path":"https://roliveros-ramos.github.io/calibrar/reference/sphereN.html","id":null,"dir":"Reference","previous_headings":"","what":"Sphere function with random noise — sphereN","title":"Sphere function with random noise — sphereN","text":"function calculates Euclidian distance point origin random displacement position.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/sphereN.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sphere function with random noise — sphereN","text":"","code":"sphereN(x, sd = 0.1, aggregate = TRUE)"},{"path":"https://roliveros-ramos.github.io/calibrar/reference/sphereN.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sphere function with random noise — sphereN","text":"x coordinates point sd standard deviation noise added position x, normal distribution mean zero used. aggregate aggregate TRUE distance returned, otherwise size projection distance among axis.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/sphereN.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sphere function with random noise — sphereN","text":"distance point x origin random displacement.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/sphereN.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Sphere function with random noise — sphereN","text":"Ricardo Oliveros–Ramos","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/sphereN.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sphere function with random noise — sphereN","text":"","code":"sphereN(rep(0, 10)) #> [1] 0.03885167"},{"path":"https://roliveros-ramos.github.io/calibrar/reference/spline_par.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict time-varying parameters using splines. — spline_par","title":"Predict time-varying parameters using splines. — spline_par","text":"Predict time-varying parameters using splines.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/spline_par.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict time-varying parameters using splines. — spline_par","text":"","code":"spline_par(par, n, knots = NULL, periodic = FALSE, period = NULL)"},{"path":"https://roliveros-ramos.github.io/calibrar/reference/spline_par.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict time-varying parameters using splines. — spline_par","text":"par Values knots n Number points. Time (independent variable) assumed 0 n length(par) equidistant points (including 0 n). knots Position knots. Default, length(x) equidistant points 0 1. Always re-scaled 0 1. periodic boolean, spline periodic? period periodic TRUE, specify time period.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/spline_par.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict time-varying parameters using splines. — spline_par","text":"list interpolates values 'x' 'time'.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/summary.calibrar.results.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary for calibration results object — summary.calibrar.results","title":"Summary for calibration results object — summary.calibrar.results","text":"Summary calibration results object","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/reference/summary.calibrar.results.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary for calibration results object — summary.calibrar.results","text":"","code":"# S3 method for class 'calibrar.results' summary(object, ..., show_par = NULL, par.only = FALSE)"},{"path":"https://roliveros-ramos.github.io/calibrar/reference/summary.calibrar.results.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary for calibration results object — summary.calibrar.results","text":"object Object class calibrar.results ... objects class calibrar.results needed comparisons. show_par Vector names positions parameters show summary. par.Show parameters summary, used one optimization results summarized.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/news/index.html","id":"calibrar-09","dir":"Changelog","previous_headings":"","what":"calibrar 0.9","title":"calibrar 0.9","text":"new optim2() equivalent stats::optim() parallel computation numerical gradients. new optimh() wrapping heuristic methods syntax stats::optim(). calibrate() function implements restart functionality Rvmmin method , useful optimization deterministic functions long runtime. Improved methods visualization results. optimization methods available calibrate() can use functions reading writing disk. Functioncalibrate() can use different method estimation phase. calibrate() generic now. Automatic stopping criteria AHR-ES method: Automatic testing using testthat package. Automatic support optimize functions produced TMB package, via method calibrate(). getCalibrationInfo(), createObjectiveFuction() getObservedData() defunct now.","code":"- 0: maxit/maxgen only     - 1: 1 OR max step reduction     - 2: relative tolerance on value (smoothing for AHR-ES)     - 3: maximum number of generations without improvement of `reltol`."},{"path":"https://roliveros-ramos.github.io/calibrar/news/index.html","id":"calibrar-03","dir":"Changelog","previous_headings":"","what":"calibrar 0.3","title":"calibrar 0.3","text":"new optimization methods available calibrate(): ‘LBFGSB3’, ‘hjn’, ‘CMA-ES’, ‘genSA’, ‘DE’, ‘soma’, ‘genoud’, ‘PSO’, ‘hybridPSO’, ‘mads’. fine control numerical gradient computations, including parallelization. replicates argument stochastic functions several minor bugs fixed getCalibrationInfo(), createObjectiveFuction() getObservedData() deprecated replaced calibration_setup(), calibration_objFn() calibration_data(). spline_par() function simplify estimation smooth time-varying parameters.","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/news/index.html","id":"calibrar-02","dir":"Changelog","previous_headings":"","what":"calibrar 0.2","title":"calibrar 0.2","text":"par argument calibrate function can list optimization methods optimx, stats::optim cmaes can used several minor bugs fixed","code":""},{"path":"https://roliveros-ramos.github.io/calibrar/news/index.html","id":"calibrar-01","dir":"Changelog","previous_headings":"","what":"calibrar 0.1","title":"calibrar 0.1","text":"First release","code":""}]
